<html>
<head>
    <title>mealImage.js test</title>
    <script src="/javascripts/jquery.js"></script>
    <script src="/javascripts/jquery-ui.js"></script>
    <script type="text/javascript" src="/javascripts/Jaml-all.js"></script>
    
    <script language="JavaScript" src="/javascripts/jsunit/jsUnitCore.js"></script>
    
	  <script src="/javascripts/rainydays/rainydays.js"></script>
	  <script src="/javascripts/rainydays/page.js"></script>
	  <script src="/javascripts/rainydays/form.js"></script>
      <script src="/javascripts/rainydays/albumupload.js"></script>
</head>
<body>

<script>
// our tests

/* MEALIMAGE.INITIALIZE */
function testAlbumUploadInitializationNormal() {
  // run standard initialization tests
	forAllInitStates(assertInitializedNormally);
}

function assertInitializedNormally(paramsUsed) {
  assertTrue("Meal image did not initialize!", RD.AlbumUpload._initialized)
  assertIsObject("RD.AlbumUpload did not initialize image array!", RD.AlbumUpload._imagesForMeal);

	// required DOM hooks (all states)
  assertIsObject("RD.AlbumUpload did not initialize image sort order node!", RD.AlbumUpload._imageSortOrderNode);
	assertEquals("RD.AlbumUpload did not properly initialize sort order node per parameter!", RD.AlbumUpload._imageSortOrderNode.attr("id"), paramsUsed.sortOrderStorageID);

  assertIsObject("RD.AlbumUpload did not initialize _albumUploadsNode!", RD.AlbumUpload._albumUploadsNode);
	assertEquals("RD.AlbumUpload did not properly initialize sort order node per parameter!", RD.AlbumUpload._albumUploadsNode.attr("id"), paramsUsed.albumNodeID);

	// optional DOM hooks (some states)
	if (paramsUsed.keyImageNodeID) {
	  assertIsObject("RD.AlbumUpload did not initialize key image node!", RD.AlbumUpload._keyImageDataNode);
		assertEquals("RD.AlbumUpload did not properly initialize sort order node per parameter!", RD.AlbumUpload._keyImageDataNode.attr("id"), paramsUsed.keyImageNodeID);
	}
	else {
		assertUndefined("Initializing defined _keyImageDataNode despite having no value!", RD.AlbumUpload._keyImageDataNode);
	}

	if (paramsUsed.placeholderNodeID) {
	  assertIsObject("RD.AlbumUpload did not initialize _placeholderNode!", RD.AlbumUpload._placeholderNode);
		assertEquals("RD.AlbumUpload did not properly initialize placeholder node per parameter!", RD.AlbumUpload._placeholderNode.attr("id"), paramsUsed.placeholderNodeID);
	}
	else {
		assertUndefined("Initializing defined _placeholderNode despite having no value!", RD.AlbumUpload._placeholderNode);
	}

	// other parameters
  assertObjectEquals("RD.AlbumUpload did not initialize clearedObject to an empty hash!", RD.AlbumUpload.clearedObject, ({}));

	for (var templateName in RD.AlbumUpload.internals._JAML_TEMPLATES) {
		assertNotNull(Jaml.templates[templateName]);
	}
}

function testAlbumUploadInitializationNoImageSortNode() {
  // make sure it throws an exception with the image sort order node missing
  _removeAlbumUploadSortOrder();
  assertThrowsException("Initializing with no match for sort order node didn't throw an error!", function() { RD.AlbumUpload.initialize(defaultInitializationParams())});
}

function testAlbumUploadInitializationNoImageSortNodeID() {
  // make sure it throws an exception if it's not passed an image sort node ID
	var params = defaultInitializationParams();
	delete params.sortOrderStorageID;
  assertThrowsException("Initializing with no sort order node didn't throw an error!", function() { RD.AlbumUpload.initialize(params) });
}

function testAlbumUploadInitializationNoAlbumUploadDiv() {
  // make sure it throws an exception with the image sort order node missing
  _removeAlbumUploadDiv();
  assertThrowsException("Initializing with no match for album upload node didn't throw an error!", function() { RD.AlbumUpload.initialize(defaultInitializationParams())});
}

function testAlbumUploadInitializationNoAlbumUploadDivID() {
  // make sure it throws an exception if it's not passed an album node ID
	var params = defaultInitializationParams();
	delete params.albumNodeID;
  assertThrowsException("Initializing with no album node didn't throw an error!", function() { RD.AlbumUpload.initialize(params) });
}


function testAlbumUploadInitializationNoKeyImageDataDiv() {
  // make sure it throws an exception when passed a key image node that doesn't exist
  _removeKeyImageDataNode();
  assertThrowsException("Initializing with no match for key image data node didn't throw an error!", function() { RD.AlbumUpload.initialize(defaultInitializationParams())});
}

function testAlbumUploadInitializationNoPlaceholderDiv() {
  // make sure it throws an exception with the placeholder node missing
  _removeAlbumUploadPlaceholder();
  assertThrowsException("Initializing with no match for placeholder node didn't throw an error!", function() { RD.AlbumUpload.initialize(defaultInitializationParams())});
}

function testAlbumUploadInitializationAnArbitraryNumberOfTimes() {
  // test RD.AlbumUpload initialization when run more than once
  var timesToTest = Math.round(100 * Math.random());
	forAllInitStates(function(paramsUsed) {
	  for (var i = 0; i < timesToTest; i++) {
	    RD.AlbumUpload.initialize(paramsUsed);
  	}

	  assertInitializedNormally(paramsUsed);
	});
}

/* NEW MEALIMAGE() */
function testAlbumUploadConstructorNormal() {
	forAllInitStates(function() {	
	  debug("Starting testAlbumUploadConstructorNormal");
	  // gather preliminary data
	  var originalNodeCount = $("#albumUploads").find("div." + RD.AlbumUpload.uploadNodeClass).length;

	  // run the code
	  var outcome = new RD.AlbumUpload();
  
	  // test RD.AlbumUpload was initialized -- assume it was done through initialization?
	  assertTrue("RD.AlbumUpload wasn't initialized when a new one was made!", RD.AlbumUpload._initialized);

	  // test returns mealImage
	  assertEquals("new RD.AlbumUpload() not constructed by RD.AlbumUpload", outcome.constructor, RD.AlbumUpload);
  
	  // if placeholder set, test removal of placeholder div once there are active images
	  if (RD.AlbumUpload._placeholderNode) {
			assertUndefined("Placeholder div did not get removed!", RD.AlbumUpload._placeholderNode.parent()[0]);
  	}

	  // test that it can be found (e.g. it's in RD.AlbumUpload.images)
	  found = RD.AlbumUpload.findByLocalId(outcome.localID);
	  if (found != outcome)
	    debug("WARNING: Found: " + showSource(found));
	  assertEquals("new RD.AlbumUpload() not in the images array! looked for " + outcome.localID, outcome, found);
  
	  // test that it has a node
	  assertNotNull("new RD.AlbumUpload() doesn't have a node!", outcome.node);
  
	  // that it's only created one
	  newNodeCount = RD.AlbumUpload._albumUploadsNode.find("div." + RD.AlbumUpload.uploadNodeClass).length;
	  assertEquals("new RD.AlbumUpload() added more or less than one node to #albumUploads (original " + originalNodeCount + ", now " + newNodeCount + ")!", originalNodeCount + 1, newNodeCount);
	  // and that it's in the right place
	  assertNotNull("new RD.AlbumUpload() didn't have a node in #albumUploads!", RD.AlbumUpload._albumUploadsNode.find(outcome.node)[0]);
  
	  // test the status
	  assertTrue("new RD.AlbumUpload() was not in created status!", outcome.isCreated());
	});
}

function testAlbumUploadConstructorNoJaml() {
	forAllInitStates(function() {
	  debug("Starting testAlbumUploadConstructorNoJaml");
  
	  // knock out the Jaml template
	  _removeJaml("albumUploadBlock");
  
	  // make sure we get an exception
	  assertThrowsException("new RD.AlbumUpload() succeeded even with Jaml template albumUploadBlock deleted!", function() {new RD.AlbumUpload()});
	})
}

function testAlbumUploadConstructorNoAlbumUploadsNode() {
	forAllInitStates(function() {
		debug("Starting testAlbumUploadConstructorNoRD.AlbumUploadsNode");
  
	  // knock out the node
	  _removeAlbumUploadDiv();
  
	  // make sure we get an exception
	  assertThrowsException("new RD.AlbumUpload() succeeded even no image upload node!", function() {new RD.AlbumUpload()});
	})
}

function testAlbumUploadConstructorAnArbitraryNumberOfTimes() {
	forAllInitStates(function() {
	  // this mainly tests that multiple creations create unique nodes
	  timesToTest = Math.round(100 * Math.random());
	  for (var i = 0; i < timesToTest; i++)
	    testAlbumUploadConstructorNormal();
    
	  // test that all the nodes are unique
	  var uniqueNodes = [];
	  for (var miIndex in RD.AlbumUpload.images()) {
	    var mi = RD.AlbumUpload.images()[miIndex];
	    for (var i in uniqueNodes) {
	      storedNode = uniqueNodes[i];
		  // we have to check the DOM nodes against each other, since we can't access the jQuery ID as of 1.4
	      assertNotEquals("Two meal images have the same node (ids " + storedNode.attr("id") + ", " + mi.node.attr("id") + ")!", storedNode[0], mi.node[0]);
	    }
	    uniqueNodes.push(mi.node);
	  }
	})
}

/* INIT FROM DATABASE * /
/* 
Other external outcomes / test cases:
- links in node have bindings to this RD.AlbumUpload
- if key, it's registered as key (RD.AlbumUpload.getKeyImage() === this)
*/
function testAlbumUploadInitFromDatabaseNormal() {
  debug("Starting testAlbumUploadInitFromDatabaseNormal");
	forAllInitStates(function() {
	  // test against all good meal images  
	  for (var testDataIndex in testData.goodDatabaseImages) {
	    // get the data passed by SWFUpload
	    var imageDetails = testData.goodDatabaseImages[testDataIndex];
    
		  protoOutcome = new RD.AlbumUpload();
			assertInitializesFromDatabaseProperly(protoOutcome, imageDetails);
	  }
	})
}

function assertInitializesFromDatabaseProperly(mealImage, imageDetails, initializationFunction) {
	// check for key image state
	var previousKeyImage = RD.AlbumUpload.getKeyPic();
	var keyImageSet = RD.AlbumUpload.isAlbumUpload(previousKeyImage);

	// test that if there's no key image, it becomes one without firing the event
	if (!keyImageSet) {
		// set up the function that will fail if the event is triggered
		debug("Key image not set, set up event checker for key image.");

		var checkEvent = function(e) {
      // only fire this for the specific meal image
      // otherwise old event handlers will cause this test to fail
      var forThis = e.mealImage && e.mealImage.localID === mealImage.localID;
     
      if (forThis) {
        fail("Becoming default key pic on load fired global event!");
      }
		}
	
		RD.AlbumUpload.handleNewKeyImage(checkEvent);
	}	

	// initializationFunction is, by default, initFromDatabase
	// but it could be any function with the same signature that inside it initializes the mealImage from the database
	// such as uploadCompleted
	var fnName = (initializationFunction ? initializationFunction : "initFromDatabase");
	//make sure we have a valid function
	assertIsFunction("assertInitializesFromDatabaseProperly did not get a valid function, got " + fnName,   mealImage[fnName])

	var originalSortOrder = RD.AlbumUpload.getSortOrder();

  // init from database
  outcome = mealImage[fnName](imageDetails);
	
  // make sure they're the same
  assertEquals("A different mealImage was returned from " + initializationFunction + " (via assertInitializesFromDatabaseProperly) than from new RD.AlbumUpload()!", mealImage.localID, outcome.localID);

  // we know that new RD.AlbumUpload() works, so we just test initFromDatabase
  // make sure we can find it by its new ID
  assertEquals("RD.AlbumUpload init'd from database could not be found by its remote ID! " + imageDetails.id, outcome, RD.AlbumUpload.findByRemoteId(imageDetails.id));
 
  // make sure all server data was saved into the meal image
  for (var key in imageDetails) {
    assertEquals("RD.AlbumUpload did not get attribute " + key + " copied from server data!", imageDetails[key], outcome[key]);
  }
 
  // make sure it calculated whether the image was horizontal or not
  assertNotNull("new Meal Image had isHorizontal null!", outcome.isHorizontal);
  assertEquals("new Meal Image's horizontal disagreed with calculations!", outcome.isHorizontal, outcome.width > outcome.height);
 
  // check that it's set the class appropriately for its dimensions
  horizFn = (outcome.isHorizontal ? assertEvaluatesToTrue : assertEvaluatesToFalse); 
  horizFn("RD.AlbumUpload had improper isHorizontal state for class forHorizontalImage! (isHorizontal: " + outcome.isHorizontal + ", class: " + outcome.node.attr("class") + ")", outcome.node.attr("class").match(/forHorizontalImage/));
  vertFn = (outcome.isHorizontal ? assertEvaluatesToFalse : assertEvaluatesToTrue);
  vertFn("RD.AlbumUpload had improper isHorizontal state for class forVerticalImage! (isHorizontal: " + outcome.isHorizontal + ", class: " + outcome.node.attr("class") + ")", outcome.node.attr("class").match(/forVerticalImage/));    
 
  // ensure dialog exists
  assertEvaluatesToTrue("RD.AlbumUpload after initFromDatabase does not have dialog!", outcome._zoomDialog);
  // and that it's a dialog by checking an option we know was set
  assertNotNull("RD.AlbumUpload's dialog is not a dialog!", outcome._zoomDialog.dialog("option", "autoOpen"));

  // make sure the uploading and inactive classes are gone
  className = outcome.node.attr("className");
  assertEvaluatesToFalse("RD.AlbumUpload after initFromDatabase still has uploading class!", className.match(/uploading/));
  assertEvaluatesToFalse("RD.AlbumUpload after initFromDatabase still has inactive class!", className.match(/inactive/));
     

	if (RD.AlbumUpload._keyImageDataNode) {
	  // see if we became the key image if appropriate (and not, if not appropriate)
		var newKeyPic = RD.AlbumUpload.getKeyPic();
	  if (!keyImageSet) {
	    // if it wasn't set, assert this is the key image
	    debug("Key image wasn't set, so we expect this to become the key image.")
	    assertTrue("Key image was not set to a meal image when it was previously empty!", RD.AlbumUpload.isAlbumUpload(newKeyPic));
	    assertEquals("Key pic was automatically set, but not to the right one!", newKeyPic.localID, outcome.localID)
	  }
	  else {
	    // assert nothing's changed
	    debug("Key image was set, so this should not have become key image.")
	    assertEquals("RD.AlbumUpload changed on initialization, even though it was previously not null!", previousKeyImage, newKeyPic);
	  }
	}

  // check for appropriate content (two links and an image)
  // if the markup changes, this will fail and be rewritten
  imageCount = outcome.node.find("img").length;
  assertEquals("Meal Image did not have one images (had " + imageCount +")!", imageCount, 1);
  linkCount = outcome.node.find("a").length;
  assertEquals("Meal Image did not have two links (had " + linkCount +")!", linkCount, 3);

	// test the deletion flag
	fail("Need to test deletion flag");

  // status is visible
  assertTrue("Meal Image after initFromDatabase did not have visible status!", outcome.isVisible());
 
  // make sure that the meal image is in the sort order now
  // it may not be the first item, since it could have been from an upload
  var currentSortOrder = RD.AlbumUpload.getSortOrder();
  debug("Got sort order! " + currentSortOrder);
  items = currentSortOrder.split(",");
  var found = false;
  for (var i in items) {
    // test each remote ID in the sort order against the current RD.AlbumUpload
    if (items[i] === outcome.id + "") {
      found = true;
      break;
    }
  }

  // assert that we found it
  assertTrue("Unable to find RD.AlbumUpload after initFromDatabase in the sort order! (MI remoteID: " + outcome.id + ", sortOrder: " + currentSortOrder + ")", found);

	// used to make sure it's the previous object
	return outcome;
}

function testAlbumUploadInitFromDatabaseWithDuplicates() {
  debug("Starting testAlbumUploadInitFromDatabaseWithDuplicates");
	forAllInitStates(function() {
	  // test against all good meal images  
	  for (testDataIndex in testData.goodDatabaseImages) {
	    // get the data passed by SWFUpload
	    var imageDetails = testData.goodDatabaseImages[testDataIndex];
    
	    // create the original
	    var original = new RD.AlbumUpload().initFromDatabase(imageDetails);

	    // gather some data
	    var mealImageArrayCount = RD.AlbumUpload.images().length;
	    var mealImageNodeCount = RD.AlbumUpload._albumUploadsNode.find("div." + RD.AlbumUpload.uploadNodeClass).length;
	    var sortOrder = RD.AlbumUpload.getSortOrder();

	    // create a duplicate
	    var duplicate = new RD.AlbumUpload();
	    var duplicateNode = duplicate.node;
	    var duplicateLocalID = duplicate.localID;
	    var newLength = RD.AlbumUpload.images().length;
	    var initOutcome = duplicate.initFromDatabase(imageDetails);
    
	    // assert the duplicate is removed completely
	    assertEquals("Duplicate initialization did not return the original version!", original, initOutcome);

	    // assert that it was cleared
	    assertCleared(duplicateLocalID);
	  }
	});
}

function testAlbumUploadInitFromDatabaseNoJaml() {
  debug("Starting testAlbumUploadInitFromDatabaseNoJaml");
  
	forAllInitStates(function() {
	  // knock out the Jaml template
	  _removeJaml("visible");
  
	  // test a sets of image data to make sure everything works
	  for (var testDataIndex in testData.goodDatabaseImages) {
	    var imageDetails = testData.goodDatabaseImages[testDataIndex];
    
	    // make sure it's an exception
	    assertThrowsException("RD.AlbumUpload.InitFromDatabase() succeeded even with Jaml template visible deleted!", function() { new RD.AlbumUpload().initFromDatabase(imageDetails); });
	  }
	})
}

function testAlbumUploadInitFromDatabaseBadData() {
  debug("Starting testAlbumUploadInitFromDatabaseNormal");
	forAllInitStates(function() {
	  // test against all good meal images  
	  for (var testDataIndex in testData.badDatabaseImages) {
	    // get the data passed by SWFUpload
	    var imageDetails = testData.badDatabaseImages[testDataIndex];
    
	    // init from database
	    protoOutcome = new RD.AlbumUpload();
	    outcome = protoOutcome.initFromDatabase(imageDetails);
    
	    assertBadServeResponse(outcome);
	  }
	})
}

function assertBadServeResponse(mealImage) {
  // verify that the _badServerResponse has been triggered
	// right now, it just verifies that it hit an unrecoverable error
	// in the future, it may verify the text displayed
	assertHitUnrecoverableError(mealImage);
}


/* INIT FROM UPLOAD */

function testInitFromUpload() {
	forAllInitStates(function() {
	  // get our class-level constants so we can get initial states
 		var originalSortOrder = RD.AlbumUpload.getSortOrder();
	
		for (var dataIndex in testData.goodFileUploads) {
			fileData = testData.goodFileUploads[dataIndex];
		
			// init from file upload
	    protoOutcome = new RD.AlbumUpload();
	    outcome = protoOutcome.initFromUpload(fileData);
    
	    // make sure the same RD.AlbumUpload is returned
	    assertEquals("A different mealImage was returned from initFromUpload than from new RD.AlbumUpload()!", protoOutcome.localID, outcome.localID);
    
	    // we know that new RD.AlbumUpload() works, so we just test initFromUpload

	    // make sure it has an object
	    assertEquals("RD.AlbumUpload init'd from upload does not have its file object!", outcome.fileObject, fileData);

	    // make sure we can find it by its object
	    assertEquals("RD.AlbumUpload init'd from upload could not be found by its fileObject!", outcome, RD.AlbumUpload.findByFileObject(fileData));

			// make sure the filename is saved
			assertEquals("RD.AlbumUpload init'd from upload does not have filename!", outcome.filename, fileData.name);
		
			// make sure it's queued
			assertIsQueued(outcome);
		
			// make sure it has Jaml content
			// in this case, just check for the presence of a filename
			assertEvaluatesToTrue("RD.AlbumUpload node after initFromUpload doesn't have Jaml content (e.g. filename)!", outcome.node.html().match(new RegExp(outcome.filename)));

			// make sure we have uploading class
			assertTrue("RD.AlbumUpload node after initFromUpload doesn't have uploading class!", outcome.node.hasClass("uploading"));

	  	// make sure the meal images node is dirty
	  	// do it in the loop so that we can know as soon as the first one is done, rather than cumulatively
	  	//assertTrue("Init from upload did not dirty the meal images field!", RD.Page.isFieldDirty(RD.AlbumUpload._albumUploadsNode));
			fail("Need to check for fileUploadStarted event with proper data!")
		}
		
		// make sure there are no changes to the sort order
		assertEquals("Sort order changed after initFromUpload, even though it shouldn't have!", originalSortOrder, RD.AlbumUpload.getSortOrder());
	})
}

function testInitFromUploadNoJaml() {  
	debug("Starting testAlbumUploadInitFromDatabaseNoJaml");
  
	forAllInitStates(function() {
	  // knock out the Jaml template
	  _removeJaml("queued");
  
	  // test a sets of image data to make sure everything works
	  for (var testDataIndex in testData.goodFileUploads) {
	    var uploadDetails = testData.goodFileUploads[testDataIndex];
    
	    // make sure it's an exception
	    assertThrowsException("RD.AlbumUpload.initFromUpload() succeeded even with Jaml template queued deleted!", function() { new RD.AlbumUpload().initFromDatabase(uploadDetails); });
	  }
	})
}

function testInitFromUploadWithDuplicates() {
	// test against all good uploads
 	debug("Starting testAlbumUploadInitFromDatabaseWithDuplicates");
 	
	forAllInitStates(function() {
		var originals = 0, duplicates = 0;
		for (testDataIndex in testData.goodDatabaseImages) {
	    // get the data passed by SWFUpload
	    var imageDetails = testData.goodFileUploads[testDataIndex];

	    // create the original
	    var original = new RD.AlbumUpload();
			originals++;
			original.initFromUpload(imageDetails);

	    // gather some data
	    var mealImageArrayCount = RD.AlbumUpload.images().length;
	    var mealImageNodeCount = RD.AlbumUpload._albumUploadsNode.find("div." + RD.AlbumUpload.uploadNodeClass).length;

	    // create a duplicate
	    var duplicate = new RD.AlbumUpload();
			duplicates++;
	    var newLength = RD.AlbumUpload.images().length;
	    var initOutcome = duplicate.initFromUpload(imageDetails);

	    // the duplicate is distinct (as compared to initFromDatabase)
	    assertNotEquals("Duplicate initialization for file upload returned the original version!", original, initOutcome);
			// there is one more node
			assertEquals("Creating a duplicate upload did not create 1 new node!", mealImageNodeCount + 1, RD.AlbumUpload._albumUploadsNode.find("div." + RD.AlbumUpload.uploadNodeClass).length);
			// there is one more database entry
			assertEquals("Creating a duplicate upload did not create 1 new array entry!", newLength, mealImageArrayCount + 1); 
	  }

		// when all is said and done, we should have as many nodes as there are duplicates and originals
		assertEquals("After creating file uploads and duplicates, total number != originals + dupes!", RD.AlbumUpload.images().length, originals + duplicates);
	})
}

function testInitFromUploadBadData() {
	// test against all good meal images
	debug("Starting testAlbumUploadInitFromDatabaseNormal");
	forAllInitStates(function() {
	  for (var testDataIndex in testData.badFileUploads) {
	    // get the data passed by SWFUpload
	    var imageDetails = testData.badFileUploads[testDataIndex];

	    // init from database
	    protoOutcome = new RD.AlbumUpload();
	    outcome = protoOutcome.initFromDatabase(imageDetails);

	    assertBadFileUpload(outcome);
		}
	})
}

function assertBadFileUpload(mealImage) {
  // verify that the _badFileUpload has been triggered
	// right now, it just verifies that it hit an unrecoverable error
	// in the future, it may verify the text displayed
	assertHitUnrecoverableError(mealImage);
}

/* UPLOAD STARTED (RD.AlbumUpload.prototype.uploadStarted) */

function testUploadStarted() {
  // get our class-level constants so we can get initial states
	forAllInitStates(function() {
	  var originalSortOrder = RD.AlbumUpload.getSortOrder();
	
		for (var dataIndex in testData.goodFileUploads) {
			fileData = testData.goodFileUploads[dataIndex];
		
			// init from file upload
	    var protoOutcome = new RD.AlbumUpload();
			mealImage = protoOutcome.initFromUpload(fileData).uploadStarted();

			// verify we got back our same mealImage
			assertEquals("uploadStarted did not return the same RD.AlbumUpload!", protoOutcome, mealImage);

			// verify it's in upload state
			assertIsUploading(mealImage);
		
			// verify it has the progressBar attribute
			assertTrue("RD.AlbumUpload after uploadStarted does not have a progress bar!", mealImage.progressBar.length > 0);
			// verify the progress bar is initialized and at 0
			assertNotNull("RD.AlbumUpload progressbar after uploadStarted is not initialized (value === null)!", mealImage.progressBar.progressbar("option", "value"));
			assertEquals("RD.AlbumUpload progressbar after uploadStarted is not set to 0 (value != 0)!", mealImage.progressBar.progressbar("option", "value"), 0);
		}	
	})
}

function testUploadStartedNoJaml() {  
	debug("Starting testUploadStartedNoJaml");
  
	forAllInitStates(function() {
	  // knock out the Jaml template
	  _removeJaml("uploading");
  
	  // test a sets of image data to make sure everything works
	  for (var testDataIndex in testData.goodFileUploads) {
	    var uploadDetails = testData.goodFileUploads[testDataIndex];
    
	    // make sure it's an exception
	    assertThrowsException("RD.AlbumUpload.uploadStarted() succeeded even with Jaml template uploading deleted!", function() { new RD.AlbumUpload().initFromDatabase(uploadDetails).uploadStarted(); });
	  }
	})
}

/*
UPLOAD CANCELED (RD.AlbumUpload.prototype.uploadCanceled)
*/

function testUploadCanceled() {
	forAllInitStates(function() {
		for (var dataIndex in testData.goodFileUploads) {
			fileData = testData.goodFileUploads[dataIndex];
		
			// init from file upload
	    var protoOutcome = new RD.AlbumUpload();
			mealImage = protoOutcome.initFromUpload(fileData).uploadStarted().uploadCanceled();

			// verify we got back our same mealImage
			assertEquals("uploadStarted did not return the same RD.AlbumUpload!", protoOutcome, mealImage);

			// verify it's in canceled state
			assertIsCanceled(mealImage);
		}	
	})
}

function testUploadCanceledNoJaml() {  
	debug("Starting testUploadCanceledNoJaml");
 
	forAllInitStates(function() {
	  // knock out the Jaml template
	  _removeJaml("canceled");
  
	  // test a sets of image data to make sure everything works
	  for (var testDataIndex in testData.goodFileUploads) {
	    var uploadDetails = testData.goodFileUploads[testDataIndex];
    
	    // make sure it's an exception
	    assertThrowsException("RD.AlbumUpload.uploadCanceled() succeeded even with Jaml template canceled deleted!", function() { new RD.AlbumUpload().initFromDatabase(uploadDetails).uploadStarted().uploadCanceled(); });
	  }
	})
}


/*
UPLOAD PROGRESSED (RD.AlbumUpload.prototype.uploadProgressed)
*/

function testUploadProgressed() {
	forAllInitStates(function() {
		_runProgressBarTest(false);
	})
}

function testUploadProgressedWithProgressBarRemovals() {
	forAllInitStates(function() {
		_runProgressBarTest(true);
	})
}

function _runProgressBarTest(removeProgressBarAtRandom) {
	// split the upload progress into a random set of intervals
	var interval = Math.round(Math.random() * 10);
	
	for (var dataIndex in testData.goodFileUploads) {
		fileData = testData.goodFileUploads[dataIndex];
		
		// init from file upload
    	var protoOutcome = new RD.AlbumUpload().initFromUpload(fileData).uploadStarted();
		for (var i = 0; i <= interval; i++) {
			// if we want to test with removing the progress bar, do so randomly half the time
			if (removeProgressBarAtRandom && Math.random() > 0.5)
				delete protoOutcome.progressBar;
				
			// increment our original value further and further
			var mealImage = protoOutcome.uploadProgressed((i === interval ? 1 : 1/(interval - i)));
			// verify we get back our same mealImage each time
			assertEquals("uploadProgressed did not return the same RD.AlbumUpload!", protoOutcome, mealImage);
			// verify that the progress bar is indeed advanced (with a 0.1 tolerance to avoid rounding errors)
			assertRoughlyEquals("uploadProgressed did not set progressBar = percentage * 100!", mealImage.progressBar.progressbar("option", "value"), (i === interval ? 100 : 100/(interval - i)), 0.1);
			// assert the status hasn't changed
			assertIsUploading(mealImage);

			// if we're testing 100%
			if (i === interval) {
				var text = mealImage.node.find(".processingMessage").html();
				assertEquals("RD.AlbumUpload progressed to 100% did not have processing text!", text, RD.AlbumUpload.text("processing_uploaded_file"));
			}
		}
		
		
	}
}

/* 
MEALIMAGE.PROTOTYPE.UPLOADERROR 
*/

function testUploadErrored() {
	forAllInitStates(function() {
		// make sure upload limit is defined
		assertNotNull("RD.AlbumUpload does not have an upload error limit!", RD.AlbumUpload.RETRY_LIMIT);

		// test recoverable errors
		for (var goodData in testData.goodFileUploads) {
			for (var recoverableError in errorData().recoverableUploadErrors) {
				// set up a meal image
				var datum = testData.goodFileUploads[goodData];
				var mi = new RD.AlbumUpload().initFromUpload(datum);

				// now error it using one of our errors
				var error = errorData().recoverableUploadErrors[recoverableError];
				mi.uploadErrored(error);

				// now verify that it's been errored
				assertHitRecoverableError(mi);
			
				// now try again up to the retry limit to make sure it ultimately unrecoverably errors
				for (var i = 0; i <= RD.AlbumUpload.RETRY_LIMIT; i++) { mi.uploadErrored(error) }
				// now verify we're in an unrecoverable state
				assertHitUnrecoverableError(mi);
			}
		}	
	
		// now test for unrecoverable errors
		for (var goodData in testData.goodFileUploads) {
			for (var unrecoverableError in errorData().unrecoverableUploadErrors) {
				// set up a meal image
				var datum = testData.goodFileUploads[goodData];
				var mi = new RD.AlbumUpload().initFromUpload(datum);

				// now error it using one of our errors
				var error = errorData().unrecoverableUploadErrors[unrecoverableError];
				mi.uploadErrored(error);

				// now verify that it's been errored
				assertHitUnrecoverableError(mi);
			}
		}
	})
}

// tests whether something has errored in a way that's not recoverable
function assertHitUnrecoverableError(mi) {
	// make sure it's errored
	assertIsErrored(mi);
	// should we assert it has the right content?
}

// tests whether something has errored in a way is not recoverable
function assertHitRecoverableError(mi) {
	// make sure it's re-queued
	assertIsQueued(mi);
	// make sure its error count is increased
	assertTrue("Meal that hit recoverable error has error count not > 0!", mi.errorCount > 0);
	// should we assert it has the right content?
}

function testUploadErrorNoJaml() {
	debug("Starting testUploadErrorNoJaml");
  
	forAllInitStates(function() {
	  // knock out the Jaml template
	  _removeJaml("errored");
  
	  // make sure we get an exception
	  assertThrowsException("uploadErroreds() succeeded even with Jaml template errored deleted!", function() {new RD.AlbumUpload().uploadErrored});
	})
}

/*
UPLOAD COMPLETED (RD.AlbumUpload.prototype.uploadCompleted)
*/

function testAlbumUploadUploadCompleted() {
	// test each of our good file uploads completing to each of our good database responses
	debug("STARTING testAlbumUploadUploadComplete");
	forAllInitStates(function() {
		for (var uploadDetails in testData.goodFileUploads) {
			for (var serverDetails in testData.goodDatabaseImages) {
				// set up the meal image
				var mealImage = new RD.AlbumUpload().initFromUpload(testData.goodFileUploads[uploadDetails]);
				// assert that it was properly (re)initialized 
				var outcome = assertInitializesFromDatabaseProperly(mealImage, testData.goodDatabaseImages[serverDetails], "uploadCompleted");
				// make sure they're the same
			  assertEquals("A different mealImage was returned from initFromDatabase (via assertInitializesFromDatabaseProperly) than from new RD.AlbumUpload()!", mealImage.localID, outcome.localID);
		
				// now clear it, otherwise we'll hit duplicates
				RD.AlbumUpload.clear(outcome.localID);
			}
		}
	})
}

function testAlbumUploadUploadCompletedBadData() {
	debug("STARTING testAlbumUploadUploadComplete");
	forAllInitStates(function() {
		for (var uploadDetails in testData.goodFileUploads) {
			for (var serverDetails in testData.badDatabaseImages) {
				// set up the meal image
				var mealImage = new RD.AlbumUpload().initFromUpload(testData.goodFileUploads[uploadDetails]);
				mealImage.uploadCompleted(testData.badDatabaseImages[serverDetails]);
			
				// assert it hit an error
				assertHitUnrecoverableError(mealImage);
					
				// now clear it, otherwise we'll hit duplicates
				RD.AlbumUpload.clear(mealImage.localID);
			}
		}
	})
}

/* 
TOGGLE DELETE (RD.AlbumUpload)
toggleDeletion
Sets the image to be deleted or not deleted.

Other outcomes / test cases:
- if it's not currently deleted, node gains the markedForDeletion class and status is DELETING
- otherwise, status is VISIBLE and the class isn't present
- executed an arbitrary number of times, the status and class are always in sync
*/

function testToggleDeletionNormal() {
	// test a toggle on and then off, checking all meal image states for appropriate responses
	forAllInitStates(function() {
		forAllGoodUploadsAndDatabaseImages(function(uploadData, serverData) {
			// test at each point in the life of the mealImage
			var mealImage = new RD.AlbumUpload();
			assertToggleDeleteHasNoEffect(mealImage);
			mealImage.uploadStarted(uploadData);
			assertToggleDeleteHasNoEffect(mealImage);
			mealImage.uploadProgressed(0.7);
			assertToggleDeleteHasNoEffect(mealImage);
		
			// now test either canceled, errored, or completed
			if ((chance = Math.random()) < 0.25) {
				mealImage.uploadCanceled();
				assertToggleDeleteHasNoEffect(mealImage);
			}
			else if (chance < 0.5) {
				// now error it out and make sure it doesn't work
				// we only need to test one type of error data, I think
				mealImage.uploadErrored(errorData().unrecoverableUploadErrors[0]);
				assertToggleDeleteHasNoEffect(mealImage);			
			}
			else {
				// now get to the point where it should work
				mealImage.uploadCompleted(serverData);
				assertToggleDeleteDoesHaveEffect(mealImage);
				assertToggleDeleteDoesHaveEffect(mealImage);
			}
			// now clear it to prevent issues
			RD.AlbumUpload.clear(mealImage.localID);
		})
	})
}

function testAlbumUploadAnArbitraryNumberOfTimes() {
	forAllInitStates(function() {
		forAllGoodUploadsAndDatabaseImages(function(uploadData, serverData) {
			var mealImage = new RD.AlbumUpload().uploadStarted(uploadData).uploadCompleted(serverData);
			var toggleCount = 0;
		
			// test a random number of times to make sure the outcome matches
			var numberToTest = Math.round(Math.random() * 100);
			for (var i = 0; i < numberToTest; i++) { 
				mealImage.toggleDeletion(); 
				toggleCount++; 
			}

			// make sure we have the right final state
			// since we start from not deleted, see if we have an odd number of toggles
			var shouldBeDeleted = (toggleCount % 2 === 1);
			if (shouldBeDeleted) {
				assertEvaluatesToTrue("RD.AlbumUpload after " + toggleCount + " random delete toggles should have had deleted class but didn't!", mealImage.node.attr("class").match(/markedForDeletion/));
				assertIsDeleting(mealImage);
			}
			else {
				assertNull("RD.AlbumUpload after " + toggleCount + " random delete toggles should not have had deleted class but did!", mealImage.node.attr("class").match(/markedForDeletion/));
				assertIsVisible(mealImage);
			}
		
			RD.AlbumUpload.clear(mealImage.localID);
		});
	})
}

function assertToggleDeleteHasNoEffect(mealImage) {
	var currentStatus = mealImage.status, currentClass = mealImage.node.attr("class");
	mealImage.toggleDeletion();
	assertEquals("RD.AlbumUpload in state " + currentClass + " had unexpected change in status with toggleDeletion!", currentStatus, mealImage.status);
	assertEquals("RD.AlbumUpload in state " + currentClass + " had unexpected change in class with toggleDeletion!", currentClass, mealImage.node.attr("class"));
}

function assertToggleDeleteDoesHaveEffect(mealImage) {
	var originalStatus = mealImage.status, originalClass = mealImage.node.attr("class");

	// see which status we should end up at
	var targetStatus = (originalStatus === RD.AlbumUpload._STATUS.deleting ? RD.AlbumUpload._STATUS.visible : RD.AlbumUpload._STATUS.deleting);
	// see if we should match or not match the class
	var targetMatchStatus = (targetStatus === RD.AlbumUpload._STATUS.visible ? false : true)

	mealImage.toggleDeletion();
	
	// test the deletion flag
	fail("Need to test deletion flag is inserted or removed properly");
	
	
	assertEquals("RD.AlbumUpload in original state " + originalStatus + " did not change to the appropriate status!", mealImage.status, targetStatus);
	var hasMatch = (!!mealImage.node.attr("class").match(/markedForDeletion/)); // need to cast to boolean
	assertTrue("RD.AlbumUpload in state " + originalStatus + " did not have appropriate change in class with toggleDeletion! " + mealImage.node.attr("class"), hasMatch === targetMatchStatus);
}

/* 
SHOWFULLIMAGE (RD.AlbumUpload.prototype.showFullImage)
*/

function testShowFullImageNormal() {
	forAllInitStates(function() {
		forAllGoodUploadsAndDatabaseImages(function(uploadData, serverData) {
			// walk through each of the stages of a RD.AlbumUploads's life and verify that it has a meal image properly
			var mealImage = new RD.AlbumUpload();
			assertDoesNotGenerateImageDialog(mealImage);
			mealImage.uploadStarted(uploadData);
			assertDoesNotGenerateImageDialog(mealImage);
			mealImage.uploadProgressed(0.7);
			assertDoesNotGenerateImageDialog(mealImage);
		
			// init from database and make sure it exists
			mealImage.uploadCompleted(serverData);
			assertHasImageDialog(mealImage);
			// now show it and make sure it's still visible
			mealImage.showFullImage();
			assertDialogIsOpen(mealImage);
			// verify it's closed
			mealImage.hideFullImage();
			assertDialogIsClosed(mealImage);
		
			// now delete it, and make sure it's still present and visible
			mealImage.toggleDeletion();
			// assert the dialog still works
			mealImage.showFullImage();
			assertDialogIsOpen(mealImage);
			mealImage.hideFullImage();
			assertDialogIsClosed(mealImage);
		
			// now clear the image so we don't get duplicates later
			RD.AlbumUpload.clear(mealImage.localID);

			// now walk through each of possible errors and make sure erroring handles this appropriately
			forEachUnrecoverableError(function(errorDetails) {
				// recoverable errors just go back into queued state
				mealImage = new RD.AlbumUpload().uploadStarted(serverData);
				mealImage.uploadErrored(errorDetails);
				assertDoesNotGenerateImageDialog(mealImage);
				RD.AlbumUpload.clear(mealImage.localID);
			});

			// now, finally, test canceled
			mealImage = new RD.AlbumUpload().uploadStarted(uploadData);
			mealImage.uploadCanceled();
			assertDoesNotGenerateImageDialog(mealImage);
		});
	})
}

function assertHasNoImageDialog(mealImage) {
	// should this test that the object actually is a meal image?
	assertUndefined("RD.AlbumUpload (state " + mealImage.status + " passed to assertHasNoImageDialog has ._zoomDialog value!", mealImage._zoomDialog);
}

function assertHasImageDialog(mealImage) {
	// should this test that the object actually is a meal image?
	assertNotNull("RD.AlbumUpload (state " + mealImage.status + "  passed to assertHasImageDialog does not have a ._zoomDialog value!", mealImage._zoomDialog);
	assertNotNull("RD.AlbumUpload (state " + mealImage.status + "  dialog is not a valid dialog (e.g. dialogObject.dialog(\"isOpen\") === null)!", mealImage._zoomDialog.dialog("isOpen"));
}

function assertDialogIsOpen(mealImage) {
	assertTrue("RD.AlbumUpload (state " + mealImage.status + "  valid dialog is not open after call to showFullImage (e.g. dialogObject.dialog(\"isOpen\") != true)!", mealImage._zoomDialog.dialog("isOpen"));
}

function assertDialogIsClosed(mealImage) {
	assertFalse("RD.AlbumUpload (state " + mealImage.status + ") valid dialog is not closed after call to closeDialog (e.g. dialogObject.dialog(\"isOpen\") != false)!", mealImage._zoomDialog.dialog("isOpen"));
}

function assertDoesNotGenerateImageDialog(mealImage) {
	// does this not have a meal image dialog, and will a call to showFullImage or hideFullImage not generate one?
	assertHasNoImageDialog(mealImage);
	mealImage.showFullImage()
	assertHasNoImageDialog(mealImage);
	mealImage.hideFullImage();
	assertHasNoImageDialog(mealImage);
}
/*
MEALIMAGE.CLEAR
*/
function testClear() {
	forAllInitStates(function() {
	  // preliminary data
	  var mealImageNodeCount = RD.AlbumUpload._albumUploadsNode.find("div." + RD.AlbumUpload.uploadNodeClass).length;
	  var sortOrder = RD.AlbumUpload.getSortOrder();

		// make our meal image
	  mi = new RD.AlbumUpload();

	  // record some data
	  var node = mi.node;
	  var localID = mi.localID;
	  var startLength = RD.AlbumUpload.images().length;

	  // set this to be the key image
	  mi.becomeKeyPic();

	  // clear unless we're testing that a given mealImage was cleared
	  RD.AlbumUpload.clear(localID);
  
	  // see if it's in the image array
		assertCleared(localID); // test that its place was taken by RD.AlbumUpload.clearedObject
	  assertEquals("Cleared meal image was removed from the internal array (old and new array lengths not equal)!", startLength,  RD.AlbumUpload.images().length);
  
	  // see if it's no longer the key pic
		if (RD.AlbumUpload._keyImageDataNode) { 
		  assertUndefined("RD.AlbumUpload was set to key pic, then cleared, but key pic accessor still returned a value!", RD.AlbumUpload.getKeyPic());
		  assertUndefined("RD.AlbumUpload was set to key pic, then cleared, but _keyPic still has a value!", RD.AlbumUpload._keyPic);
		  assertEquals("RD.AlbumUpload was set to key pic, then cleared, but _keyImageDataNode still has a value!", RD.AlbumUpload._keyImageDataNode.val(), "");
		}

	  // see if we can find the node or any remnant in the DOM
	  assertEquals("Cleared meal image left behind something in the DOM (#albumUploads child counts not equal)!", mealImageNodeCount,  RD.AlbumUpload._albumUploadsNode.find("div." + RD.AlbumUpload.uploadNodeClass).length);
	  assertUndefined("Able to find cleared meal image ID in the DOM!", $("#" + RD.AlbumUpload.uploadNodeClass).find(node)[0]);

	  // see if the sort order has been restored
	  assertEquals("Original sort order not restored after clear!", sortOrder, RD.AlbumUpload.getSortOrder());

	  if (RD.AlbumUpload._placeholderNode) {
			// test return of placeholder div if there are no more active images
		  assertNotNull("Placeholder div did not get returned!", RD.AlbumUpload._placeholderNode.parent()[0]);
		}
	})
}

function testClearWithInvalidID() {
 	forAllInitStates(function() {
	 	// make a meal image to test changes with
	  mi = new RD.AlbumUpload();
	  // record some data
	  var startLength = RD.AlbumUpload.images().length;
	  var mealImageNodeCount =RD.AlbumUpload._albumUploadsNode.find("div." + RD.AlbumUpload.uploadNodeClass).length;
	  var sortOrder = RD.AlbumUpload.getSortOrder();

	  // clear unless we're testing that a given mealImage was cleared
	  RD.AlbumUpload.clear(-999);
  
	  // make sure nothing's changed
	  // see if it's in the dom list
	  assertEquals("Meal image length changed on clear for invalid localID!", startLength,  RD.AlbumUpload.images().length);

	  // make sure nothing's changed in the DOM
	  assertEquals("Clearing an invalid localID changed DOM content!", mealImageNodeCount,  RD.AlbumUpload._albumUploadsNode.find("div." + RD.AlbumUpload.uploadNodeClass).length);
	})
}

function testClearAnArbitraryNumberOfTimes() {
	forAllInitStates(function() {
	  var timesToTest = Math.round(10 * Math.random());
	  var nodesCreated = [];
	  var nodesCleared = [];
	  var nodesNotCleared = [];
  
	  for (var i = 0; i < timesToTest; i++){
	    var mi = new RD.AlbumUpload();
	    nodesCreated.push(mi);
	    var toDo = Math.random();
	    if (toDo < 0.4) {
	      // clear the node
	      nodesCleared.push(mi);
	      RD.AlbumUpload.clear(mi.localID);
	    }
	    else {
	      // initialize with random data for sort order
	      mi.initFromDatabase(databaseDataFromIndex(mi.localID));
	      // and note not cleared
	      nodesNotCleared.push(mi);

	      if (toDo > 0.9) {
	        // clear an invalid number just to test that
	        RD.AlbumUpload.clear(-999);
	      }
	    }
	  }
  
	  // now see if everything matches up
	  // preliminary data
	  var imagesInArray = RD.AlbumUpload.images().length;
	  var mealImageNodeCount = RD.AlbumUpload._albumUploadsNode.find("div." + RD.AlbumUpload.uploadNodeClass).length;
	  var sortOrder = RD.AlbumUpload.getSortOrder().split(",");
  
	  // make sure all the numbers check out
	  assertEquals("After random creating and clearing, nodesCreated != nodesCleared + nodesNotCleared!", nodesCreated.length,  nodesCleared.length + nodesNotCleared.length);

	  // make sure images has everything
	  assertEquals("After random creating and clearing, image array list isn't equal to the total number created!", imagesInArray,  nodesCreated.length);

	  // make sure the DOM list has the right number of nodes
	  assertEquals("Nodes left in the DOM after clearing and creating are not what's expected!", nodesNotCleared.length,  RD.AlbumUpload._albumUploadsNode.find("div." + RD.AlbumUpload.uploadNodeClass).length);
  
	  // make sure all cleared nodes are set to the clearedObject placeholder
	  // and that their DOM node is gone
	  for (var i in nodesCleared) {
	    var mi = nodesCleared[i];
	    assertEquals("RD.AlbumUpload cleared at random was not set to clearedObject!", RD.AlbumUpload.clearedObject, RD.AlbumUpload.findByLocalId(mi.localID));
	    assertEquals("RD.AlbumUpload cleared at random still attached to a node!", 0, mi.node.parent().length);
	    // ensure it's not in the sorted list
	  }
  
	  // make sure none of the nodesNotCleared are set to the clearedObject placeholder and all have localID's
	  for (var i in nodesNotCleared) {
	    var mi = nodesNotCleared[i];
	    assertNotEquals("RD.AlbumUpload not cleared at random was set to clearedObject!", RD.AlbumUpload.clearedObject, mi);
	    assertEvaluatesToTrue("RD.AlbumUpload not cleared at random could not be found by localID!", RD.AlbumUpload.findByLocalId(mi.localID));
	    assertEvaluatesToTrue("RD.AlbumUpload not cleared at random not attached to a node!", mi.node.parent().length > 0);

	    // make sure it's in the sort order, since it was initialized
	    foundInSortOrder = false;
	    for (var j in sortOrder) {
	      if (sortOrder[j] === mi.id + ""){ // convert type
	        foundInSortOrder = true;
	        break;
	      }
	    }
	    assertTrue("After random clearing and creating, unable to find uncleared node in sort order!", foundInSortOrder);
	  }

	  // see if the sort order has the right number of elements
	  assertEquals("Sort order after random creation and clearing not equal to the # of nodes left! ", sortOrder.length, nodesNotCleared.length);
	})
}

/* MEALIMAGE.ISMEALIMAGE */

// this method tests both individual objects (for use in other functions)
// as well as the generic test suite
function testIsAlbumUpload() {
	forAllInitStates(function() {
	  // groups to test
	  var testSubjects = [];
		// test the default good and bad suites of data
	  testSubjects.push({data: testData.goodDatabaseImages, shouldSucceed: true, initMethod: "initFromDatabase"});
	  testSubjects.push({data: testData.badDatabaseImages, shouldSucceed: false, initMethod: "initFromDatabase"});
	  testSubjects.push({data: testData.goodFileUploads, shouldSucceed: true, initMethod: "initFromUpload"});
	  testSubjects.push({data: testData.badFileUploads, shouldSucceed: false, initMethod: "initFromUpload"});
  
	  // also test random objects
	  testSubjects.push({items: ["random object", 2, null, ([]), {id: 2}, {
	    thumbImageURL:"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/4865/DSC01152_thumb_vertical.JPG",
	    "width":3000,
	    "fullImageURL":"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/4865/DSC01152.JPG",
	    "isKey":false,
	    "height":4000,
	    "id":4865,
	    localID: 0
	  }, Math, Array], shouldSucceed: false});

	  // now test the data
	  for (var testGroupIndex in testSubjects) {
	    var testingData = testSubjects[testGroupIndex];
	    var expectSuccess = testingData.shouldSucceed;
    
	    if (!testingData.items) testingData.items = [];
	    if (testingData.data) {
	        // make sure we have the right information needed to run the tests
	      if (typeof(testingData.data) === "object" && !testingData.initMethod || typeof(RD.AlbumUpload.prototype[testingData.initMethod]) != "function")
	        throw("Data given to testIsRD.AlbumUpload did not come with an initMethod!");
      
	      for (var datumIndex in testingData.data) {
	        var datum = testingData.data[datumIndex];

	        var mi = new RD.AlbumUpload();
	        // the new RD.AlbumUpload should always pass
	        assertTrue("new RD.AlbumUpload() is not a RD.AlbumUpload!", RD.AlbumUpload.isAlbumUpload(mi));      
	        testingData.items.push(mi[testingData.initMethod](datum));
	      }      
	    }

	    for (var dataIndex in testData.items) {
	      var mealImage = testGroup[dataIndex];

	      // now see if this is what we expect
	      assertTrue("RD.AlbumUpload.isAlbumUpload() did not return " + expectSuccess + " as expected!", RD.AlbumUpload.isAlbumUpload(mealImage));
	    }
	  }  
	})
}

/* MEALIMAGE STATUS ACCESSORS */

function testStatusAccessors() {
	forAllInitStates(function() {
		var mi = new RD.AlbumUpload();
	
		// sets of assertions to test whether things are or are not in certain states
		var assertions = [];
		assertions["created"] = {up: assertIsCreated, down: assertIsNotCreated}; 
		assertions["visible"] = {up: assertIsVisible, down: assertIsNotVisible};
		assertions["queued"] = {up: assertIsQueued, down: assertIsNotQueued};
		assertions["uploading"] = {up: assertIsUploading, down: assertIsNotUploading};
		assertions["errored"] = {up: assertIsErrored, down: assertIsNotErrored};
		assertions["deleting"] = {up: assertIsDeleting, down: assertIsNotDeleting};
		assertions["canceled"] = {up: assertIsCanceled, down: assertIsNotCanceled};

		// make sure the assertion tests match up with 
		assertEquals("Discrepancy between assertions for status checking and actual statuses!", assertions.length, RD.AlbumUpload._STATUS.length);
	
		var assertionsTested = [];
	
		for (var status in RD.AlbumUpload._STATUS) {
			mi.status = RD.AlbumUpload._STATUS[status];
			var foundStatus = false;
		
			for (var testAgainstStatus in assertions) {
				assertion = assertions[testAgainstStatus];
				if (status === testAgainstStatus) {
					// make sure the status' accessor returns true
					assertion.up(mi);

					// track that we used this accessor
					assertionsTested[testAgainstStatus] = true;
					// note that this status was found
					foundStatus = true;
				}
				else
					// make sure that other accessors than the appropriate one fail
					assertion.down(mi);
			}
		
			// make sure the status found an appropriate accessor
			assertTrue("Status " + status + " did not have an accessor in testStatusAccessors!", foundStatus);
		}
	
		// make sure all our accessors set up for testing were indeed tested
		for (var assertionThatShouldHaveBeenTested in assertions) {
			assertNotNull("Assertion " + assertionThatShouldHaveBeenTested + " not tested!", assertionsTested[assertionThatShouldHaveBeenTested]);
		}
	})
}

// status checkers expecting true
function assertIsCreated(mi) { assertTrue("RD.AlbumUpload expected to be in created status!", mi.isCreated()); }
function assertIsVisible(mi) { assertTrue("RD.AlbumUpload expected to be in visible status!", mi.isVisible()); }
function assertIsErrored(mi) { assertTrue("RD.AlbumUpload expected to be in errored status!", mi.isErrored()); }
function assertIsQueued(mi) {	assertTrue("RD.AlbumUpload expected to be in queued status!", mi.isQueued()); }
function assertIsCanceled(mi) { assertTrue("RD.AlbumUpload expected to be in canceled status!", mi.isCanceled()); }
function assertIsDeleting(mi) { assertTrue("RD.AlbumUpload expected to be in deleting status!", mi.isDeleting()); }
function assertIsUploading(mi) { assertTrue("RD.AlbumUpload expected to be in uploading status!", mi.isUploading()); }

// status checkers expecting false
function assertIsNotCreated(mi) { assertFalse("AlbumUpload expected NOT to be in created status!", mi.isCreated()); }
function assertIsNotVisible(mi) { assertFalse("AlbumUpload expected NOT to be in visible status!", mi.isVisible()); }
function assertIsNotErrored(mi) { assertFalse("AlbumUpload expected NOT to be in errored status!", mi.isErrored()); }
function assertIsNotQueued(mi) {	assertFalse("AlbumUpload expected NOT to be in queued status!", mi.isQueued()); }
function assertIsNotCanceled(mi) { assertFalse("AlbumUpload expected NOT to be in canceled status!", mi.isCanceled()); }
function assertIsNotDeleting(mi) { assertFalse("AlbumUpload expected NOT to be in deleting status!", mi.isDeleting()); }
function assertIsNotUploading(mi) { assertFalse("AlbumUpload expected NOT to be in uploading status!", mi.isUploading()); }

function assertCleared(localID) {
	// check the permanent marker of being cleared
	// make sure that place in the meal object is set to the clearedObject
	assertEquals("Cleared meal image's place was not set to clearedObject!", RD.AlbumUpload.images()[localID], RD.AlbumUpload.clearedObject);
}


/*
IS RETRYING (RD.AlbumUpload.prototype.isRetrying)
*/

function testIsRetrying() {
	forAllInitStates(function() {
		// test it in all the appropriate stages
		var mealImage = new RD.AlbumUpload();

		// go through all the statuses and make sure isRetrying responds appropriately
		for (var statusName in RD.AlbumUpload._STATUS) {
			mealImage.status = RD.AlbumUpload._STATUS[statusName];
			delete mealImage.errorCount;

			// test with no errorCount
			assertFalse("RD.AlbumUpload with undefined retryCount and in status " + statusName + " returned true for isRetrying!", mealImage.isRetrying());

			// test with null errorCount
			mealImage.errorCount = null;
			assertFalse("RD.AlbumUpload with null retryCount and in status " + statusName + " returned true for isRetrying!", mealImage.isRetrying());
		
			// test with 0 errorCount
			mealImage.errorCount = 0;
			assertFalse("RD.AlbumUpload with 0 retryCount and in status " + statusName + " returned true for isRetrying!", mealImage.isRetrying());

			// test with 1 for error count 
			mealImage.errorCount = 1;
			if (statusName === "queued")
				assertTrue("RD.AlbumUpload with 1 retryCount and in status " + statusName + " returned false for isRetrying!", mealImage.isRetrying());
			else
				assertFalse("RD.AlbumUpload with 1 retryCount and in status " + statusName + " returned true for isRetrying!", mealImage.isRetrying());
		
			// test random number > 0
			mealImage.errorCount = Math.round(100 * Math.random()) + 1;
			if (statusName === "queued")
				assertTrue("RD.AlbumUpload with " + mealImage.errorCount + " retryCount and in status " + statusName + " returned false for isRetrying!", mealImage.isRetrying());
			else
				assertFalse("RD.AlbumUpload with " + mealImage.errorCount + " retryCount and in status " + statusName + " returned true for isRetrying!", mealImage.isRetrying());
		
		}
	})
}

/*
SHOULD CANCEL UPLOAD (RD.AlbumUpload.prototype.shouldCancelUpload)
*/

function testShouldCancelUpload() {
	forAllInitStates(function() {
		// test it in all the appropriate stages
		var mealImage = new RD.AlbumUpload();

		// go through all the statuses and make sure isRetrying responds appropriately
		for (var statusName in RD.AlbumUpload._STATUS) {
			mealImage.status = RD.AlbumUpload._STATUS[statusName];
			delete mealImage.errorCount;

			// test with no errorCount
			assertFalse("RD.AlbumUpload with undefined retryCount and in status " + statusName + " returned true for shouldCancelUpload!", mealImage.shouldCancelUpload());

			// test with null errorCount
			mealImage.errorCount = null;
			assertFalse("RD.AlbumUpload with null retryCount and in status " + statusName + " returned true for shouldCancelUpload!", mealImage.shouldCancelUpload());
		
			// test with 0 errorCount
			mealImage.errorCount = 0;
			assertFalse("RD.AlbumUpload with 0 retryCount and in status " + statusName + " returned true for shouldCancelUpload!", mealImage.shouldCancelUpload());

			// test with RD.AlbumUpload.RETRY_LIMIT for error count 
			mealImage.errorCount = RD.AlbumUpload.RETRY_LIMIT;
			assertFalse("RD.AlbumUpload with RD.AlbumUpload.RETRY_LIMIT retryCount and in status " + statusName + " returned true for shouldCancelUpload!", mealImage.shouldCancelUpload());

			// test with RD.AlbumUpload.RETRY_LIMIT + some number for error count 
			// add an extra 1 because Math.round(Math.random * 10) can sometimes be 0
			mealImage.errorCount = RD.AlbumUpload.RETRY_LIMIT + Math.round(Math.random() * 10) + 1; 
			assertTrue("RD.AlbumUpload with " + mealImage.errorCount + " retryCount and in status " + statusName + " returned true for shouldCancelUpload!", mealImage.shouldCancelUpload());
		}
	})
}

/*
RD.AlbumUpload.prototype.images()
Returns the images array.

Assumptions:
- RD.AlbumUpload._imagesForMeal exists (failure: re-initialize, which creates an empty array, and hence returns null)
*/

function testImages() {
	forAllInitStates(function() {
		// test that it returns an array, and subsequent calls return the same array
		var result = RD.AlbumUpload.images();
		// make sure it's the same object
		assertEquals("MeaLImages called twice did not return the same images array!", result, RD.AlbumUpload.images());
		// make sure it's an array
		assertEquals("RD.AlbumUpload images() is not an array!", Array, RD.AlbumUpload.images().constructor);
	
		// now make sure it will create a new array if it's blank
		delete RD.AlbumUpload._imagesForMeal;
		assertNotNull("RD.AlbumUpload.images() failed to create a new image array when it was deleted!", RD.AlbumUpload.images());
	})
}

/*
RD.AlbumUpload.prototype.findByLocalId
*/

function testFindByLocalId() {
	forAllInitStates(function() {
		// test whether it works properly to start
		assertUndefined("RD.AlbumUpload.testFindByLocalId didn't return null for undefined input!", RD.AlbumUpload.findByLocalId());
		assertUndefined("RD.AlbumUpload.testFindByLocalId didn't return null for null input!", RD.AlbumUpload.findByLocalId(null));
		assertUndefined("RD.AlbumUpload.testFindByLocalId didn't return null for string input!", RD.AlbumUpload.findByLocalId("abc"));
		assertUndefined("RD.AlbumUpload.testFindByLocalId didn't return null for input 0 that doesn't exist!", RD.AlbumUpload.findByLocalId(0));
		assertUndefined("RD.AlbumUpload.testFindByLocalId didn't return null for input (2) that doesn't exist!", RD.AlbumUpload.findByLocalId(2));

		// create a bunch of meal images
		var localIDs = [];
		var albumUploads = [];
		forEachGoodUpload(function(uploadData) {
			var mi = new RD.AlbumUpload();
			localIDs.push(mi.localID);
			albumUploads.push(mi);
			if (Math.random() > 0.5) mi.uploadStarted(uploadData);
		});
	
		// now see if everything works both for bad inputs and good inputs
		assertUndefined("After creating, RD.AlbumUpload.testFindByLocalId didn't return null for undefined input!", RD.AlbumUpload.findByLocalId());
		assertUndefined("After creating, RD.AlbumUpload.testFindByLocalId didn't return null for null input!", RD.AlbumUpload.findByLocalId(null));
		assertUndefined("After creating, RD.AlbumUpload.testFindByLocalId didn't return null for string input!", RD.AlbumUpload.findByLocalId("abc"));
	
		for (var idIndex in localIDs) {
			var result = RD.AlbumUpload.findByLocalId(localIDs[idIndex]);
			assertEvaluatesToTrue("Unable to find object from a created mealImage's local ID!", result);
			assertTrue("Object found by local ID wasn't an actual RD.AlbumUpload!", RD.AlbumUpload.isAlbumUpload(result));
		}
	
		for (var objIndex in albumUploads) {
			var result = RD.AlbumUpload.findByLocalId(albumUploads[objIndex].localID);
			assertEvaluatesToTrue("Unable to find object from object's ID from a created mealImage's local ID!", result);
			assertTrue("Object found by local ID from object's ID wasn't an actual RD.AlbumUpload!", RD.AlbumUpload.isAlbumUpload(result));
		}
	})
}

/*
RD.AlbumUpload.prototype.findByRemoteId
*/

function testFindByRemoteId() {
	forAllInitStates(function() {
		// test whether it works properly to start
		assertUndefined("RD.AlbumUpload.testFindByRemoteId didn't return undefined for undefined input!", RD.AlbumUpload.findByRemoteId());
		assertUndefined("RD.AlbumUpload.testFindByRemoteId didn't return undefined for null input!", RD.AlbumUpload.findByRemoteId(null));
		assertUndefined("RD.AlbumUpload.testFindByRemoteId didn't return undefined for string input!", RD.AlbumUpload.findByRemoteId("abc"));
		assertUndefined("RD.AlbumUpload.testFindByRemoteId didn't return undefined for input 0 that doesn't exist!", RD.AlbumUpload.findByRemoteId(0));
		assertUndefined("RD.AlbumUpload.testFindByRemoteId didn't return undefined for input (2) that doesn't exist!", RD.AlbumUpload.findByRemoteId(2));

		// create a bunch of meal images
		var remoteIDs = [];
		var albumUploads = [];
	
		// for each set of server data, create some regular RD.AlbumUploads randomly
		// stopping once we randomly assign the server data (we don't want duplicates!)
		forEachGoodDatabaseImage(function(serverData) {
			var set = false;
			forEachGoodUpload(function(uploadData) {	
				if (set) return;
			
				// create a new meal image	
				var mi = new RD.AlbumUpload();
						
				// randomly choose what's to happen
				var chance = Math.random();
				if (chance < 0.75) {
					mi.uploadStarted(uploadData);

					if (chance < 0.5) {
						// give us 50/50 chance to assign the unique server data, at which point we break the loop
						mi.uploadCompleted(serverData);
						remoteIDs.push(mi.id);
						albumUploads.push(mi);
					
						// mark us to stop
						set = true;
					}
				}
			})
		});
	
		// now see if everything works both for bad inputs and good inputs
		assertUndefined("After creating, RD.AlbumUpload.testFindByRemoteId didn't return undefined for undefined input!", RD.AlbumUpload.findByRemoteId());
		assertUndefined("After creating, RD.AlbumUpload.testFindByRemoteId didn't return undefined for null input!", RD.AlbumUpload.findByRemoteId(null));
		assertUndefined("After creating, RD.AlbumUpload.testFindByRemoteId didn't return undefined for string input!", RD.AlbumUpload.findByRemoteId("abc"));
	
		for (var idIndex in remoteIDs) {
			var result = RD.AlbumUpload.findByRemoteId(remoteIDs[idIndex]);
			assertEvaluatesToTrue("Unable to find object from a created mealImage's remote ID!", result);
			assertTrue("Object found by remote ID wasn't an actual RD.AlbumUpload!", RD.AlbumUpload.isAlbumUpload(result));
		}
	
		for (var objIndex in albumUploads) {
			var result = RD.AlbumUpload.findByRemoteId(albumUploads[objIndex].id);
			assertEvaluatesToTrue("Unable to find object from object's remote ID from a created mealImage's remote ID!", result);
			assertTrue("Object found by remote ID from object's ID wasn't an actual RD.AlbumUpload!", RD.AlbumUpload.isAlbumUpload(result));
		}
	})
}

/*
RD.AlbumUpload.prototype.findByFileObject
*/

function testFindByFileObject() {
	forAllInitStates(function() {
		// test whether it works properly to start
		assertUndefined("RD.AlbumUpload.findByFileObject didn't return undefined for undefined input!", RD.AlbumUpload.findByFileObject());
		assertUndefined("RD.AlbumUpload.findByFileObject didn't return undefined for null input!", RD.AlbumUpload.findByFileObject(null));
		assertUndefined("RD.AlbumUpload.findByFileObject didn't return undefined for string input!", RD.AlbumUpload.findByFileObject("abc"));
		assertUndefined("RD.AlbumUpload.findByFileObject didn't return undefined for input 0 that doesn't exist!", RD.AlbumUpload.findByFileObject({}));
		assertUndefined("RD.AlbumUpload.findByFileObject didn't return undefined for input (2) that doesn't exist!", RD.AlbumUpload.findByFileObject({name: "abc"}));

		// create a bunch of meal images
		var fileObjects = [];
		var albumUploads = [];
	
		// for each set of server data, create some regular RD.AlbumUploads randomly
		// stopping once we randomly assign the server data (we don't want duplicates!)
		forEachGoodUpload(function(uploadData) {	
			// create a new meal image	
			var mi = new RD.AlbumUpload();
			mi.initFromUpload(uploadData);

			fileObjects.push(uploadData);
			albumUploads.push(mi);
		});
	
		// now see if everything works both for bad inputs and good inputs
		assertUndefined("After creating, RD.AlbumUpload.findByFileObject didn't return undefined for undefined input!", RD.AlbumUpload.findByFileObject());
		assertUndefined("After creating, RD.AlbumUpload.findByFileObject didn't return undefined for null input!", RD.AlbumUpload.findByFileObject(null));
		assertUndefined("After creating, RD.AlbumUpload.findByFileObject didn't return undefined for string input!", RD.AlbumUpload.findByFileObject("abc"));
		assertUndefined("After creating, RD.AlbumUpload.findByFileObject didn't return undefined for object input!", RD.AlbumUpload.findByFileObject({name: "abc"}));
	
		for (var fileObjIndex in fileObjects) {
			var result = RD.AlbumUpload.findByFileObject(fileObjects[fileObjIndex]);
			assertEvaluatesToTrue("Unable to find object from a created mealImage's file object!", result);
			assertTrue("Object found by file object wasn't an actual RD.AlbumUpload!", RD.AlbumUpload.isAlbumUpload(result));
		}
	
		for (var objIndex in albumUploads) {
			var result = RD.AlbumUpload.findByFileObject(albumUploads[objIndex].fileObject);
			assertEvaluatesToTrue("Unable to find object from object's file object from a created mealImage's file object!", result);
			assertTrue("Object found by file object from object's ID wasn't an actual RD.AlbumUpload!", RD.AlbumUpload.isAlbumUpload(result));
		}
	})
}

function testFindByFileObjectWithCanceledAndDeleted() {
	forAllInitStates(function() {
		// for each set of server data, create some regular RD.AlbumUploads randomly
		// stopping once we randomly assign the server data (we don't want duplicates!)
		var limit = Math.round(Math.random() * 100) + 10;
		var uploadDatums = [], uncanceledObjects = [], canceledObjects = [], erroredObjects = [];
	
		for (var i = 0; i < limit; i++) {
			// create a new meal image and set the upload started	
			debug("here" + i);
			var mi = new RD.AlbumUpload();

			var datum = uploadDataFromIndex(i);
			debug("Datum id: " + datum.id);
			uploadDatums.push(datum);
		
			// start the upload
			mi.initFromUpload(datum);
		
			// now randomly assign it to a state
			if (i % 2 === 0) {
				mi.uploadCanceled();
				canceledObjects.push(datum);
				debug("canceling " + i + ", state is " + mi.status);
			}
			else if (i % 3 === 0) {
				mi.uploadErrored({});
				erroredObjects.push(datum);
			}
			else {
				uncanceledObjects.push(datum);
			}
		};
	
		debug("Length of canceled: " + canceledObjects.length + ", uncanceledObjects: " + uncanceledObjects.length + ", errored: " + erroredObjects.length);
	
		var withCanceled = {includeCanceled: true};
		var withErrored = {includeErrored: true};
		var withBoth = {includeErrored: true, includeCanceled: true};
	
		// now test that we find all the uncanceled, canceled, and errored ones with the appropriate options
		for (var objIndex in uncanceledObjects) {
			var result = RD.AlbumUpload.findByFileObject(uncanceledObjects[objIndex]);
			assertIsAlbumUpload(result);
			result = RD.AlbumUpload.findByFileObject(uncanceledObjects[objIndex], withCanceled);
			assertIsAlbumUpload(result);
			result = RD.AlbumUpload.findByFileObject(uncanceledObjects[objIndex], withErrored);
			assertIsAlbumUpload(result);
			result = RD.AlbumUpload.findByFileObject(uncanceledObjects[objIndex], withBoth);
			assertIsAlbumUpload(result);
		}
	
		for (var objIndex in canceledObjects) {
			var result = RD.AlbumUpload.findByFileObject(canceledObjects[objIndex]);
			assertUndefined("Canceled object found by findByFileObject with no params!", result);
			result = RD.AlbumUpload.findByFileObject(canceledObjects[objIndex], withCanceled);
			assertIsAlbumUpload(result);
			result = RD.AlbumUpload.findByFileObject(canceledObjects[objIndex], withErrored);
			assertUndefined("Canceled object found by findByFileObject with only errored!", result);
			if (result) debug("BAD RESULT is " + showSource(result));
			result = RD.AlbumUpload.findByFileObject(canceledObjects[objIndex], withBoth);
			assertIsAlbumUpload(result);
		}
	
		for (var objIndex in erroredObjects) {
			var result = RD.AlbumUpload.findByFileObject(erroredObjects[objIndex]);
			assertUndefined("Errored object found by findByFileObject with no params!", result);
			result = RD.AlbumUpload.findByFileObject(erroredObjects[objIndex], withCanceled);
			assertUndefined("Errored object found by findByFileObject with only canceled!", result);
			result = RD.AlbumUpload.findByFileObject(erroredObjects[objIndex], withErrored);
			assertIsAlbumUpload(result);
			result = RD.AlbumUpload.findByFileObject(erroredObjects[objIndex], withBoth);
			assertIsAlbumUpload(result);
		}
	})
}

function testFindByFileObjectDBTest() {
	forAllInitStates(function() {
		var dbObjects = [];
		forEachGoodDatabaseImage(function(serverData) {
			var mi = new RD.AlbumUpload().initFromDatabase(serverData);
			assertUndefined("Able to find meal image init'd from database through file object!", RD.AlbumUpload.findByFileObject(mi.fileObject));
		});
	})
}

function testFindByFileName() {
	forAllInitStates(function() {
		// test whether it works properly to start
		assertUndefined("RD.AlbumUpload.findByFilename didn't return undefined for undefined input!", RD.AlbumUpload.findByFilename());
		assertUndefined("RD.AlbumUpload.findByFilename didn't return undefined for null input!", RD.AlbumUpload.findByFilename(null));
		assertUndefined("RD.AlbumUpload.findByFilename didn't return undefined for string input!", RD.AlbumUpload.findByFilename("abc"));
		assertUndefined("RD.AlbumUpload.findByFilename didn't return undefined for input 0 that doesn't exist!", RD.AlbumUpload.findByFilename({}));
		assertUndefined("RD.AlbumUpload.findByFilename didn't return undefined for input (2) that doesn't exist!", RD.AlbumUpload.findByFilename({name: "abc"}));

		// create a bunch of meal images
		var fileNames = [];
		var albumUploads = [];
	
		// for each set of server data, create some regular RD.AlbumUploads randomly
		// stopping once we randomly assign the server data (we don't want duplicates!)
		forEachGoodUpload(function(uploadData) {	
			// create a new meal image	
			var mi = new RD.AlbumUpload();
			mi.initFromUpload(uploadData);

			fileNames.push(uploadData.name);
			albumUploads.push(mi);
		});
	
		// now see if everything works both for bad inputs and good inputs
		assertUndefined("After creating, RD.AlbumUpload.findByFilename didn't return undefined for undefined input!", RD.AlbumUpload.findByFilename());
		assertUndefined("After creating, RD.AlbumUpload.findByFilename didn't return undefined for null input!", RD.AlbumUpload.findByFilename(null));
		assertUndefined("After creating, RD.AlbumUpload.findByFilename didn't return undefined for string input!", RD.AlbumUpload.findByFilename("abc"));
		assertUndefined("After creating, RD.AlbumUpload.findByFilename didn't return undefined for object input!", RD.AlbumUpload.findByFilename({name: "abc"}));
	
		for (var fileObjIndex in fileNames) {
			var result = RD.AlbumUpload.findByFilename(fileNames[fileObjIndex]);
			assertEvaluatesToTrue("Unable to find object from a created mealImage's file name!", result);
			assertTrue("Object found by file object wasn't an actual RD.AlbumUpload!", RD.AlbumUpload.isAlbumUpload(result));
		}
	
		for (var objIndex in albumUploads) {
			var result = RD.AlbumUpload.findByFilename(albumUploads[objIndex].filename);
			assertEvaluatesToTrue("Unable to find object from object's file object from a created mealImage's file object!", result);
			assertTrue("Object found by file object from object's ID wasn't an actual RD.AlbumUpload!", RD.AlbumUpload.isAlbumUpload(result));
		}
	})
}

function testFindByFileNameWithCanceledAndDeleted() {
	forAllInitStates(function() {
		// for each set of server data, create some regular RD.AlbumUploads randomly
		// stopping once we randomly assign the server data (we don't want duplicates!)
		var limit = Math.round(Math.random() * 100) + 10;
		var uploadDatums = [], uncanceledObjects = [], canceledObjects = [], erroredObjects = [];
	
		for (var i = 0; i < limit; i++) {
			// create a new meal image and set the upload started	
			debug("here" + i);
			var mi = new RD.AlbumUpload();

			var datum = uploadDataFromIndex(i);
			var name = datum.name;
		
			debug("Datum id: " + datum.id);
			uploadDatums.push(name);
		
			// start the upload
			mi.initFromUpload(datum);
		
			// now randomly assign it to a state
			if (i % 2 === 0) {
				mi.uploadCanceled();
				canceledObjects.push(name);
				debug("canceling " + i + ", state is " + mi.status);
			}
			else if (i % 3 === 0) {
				mi.uploadErrored({});
				erroredObjects.push(name);
			}
			else {
				uncanceledObjects.push(name);
			}
		};
	
		debug("Length of canceled: " + canceledObjects.length + ", uncanceledObjects: " + uncanceledObjects.length + ", errored: " + erroredObjects.length);
	
		var withCanceled = {includeCanceled: true};
		var withErrored = {includeErrored: true};
		var withBoth = {includeErrored: true, includeCanceled: true};
	
		// now test that we find all the uncanceled, canceled, and errored ones with the appropriate options
		for (var objIndex in uncanceledObjects) {
			var result = RD.AlbumUpload.findByFilename(uncanceledObjects[objIndex]);
			assertIsAlbumUpload(result);
			result = RD.AlbumUpload.findByFilename(uncanceledObjects[objIndex], withCanceled);
			assertIsAlbumUpload(result);
			result = RD.AlbumUpload.findByFilename(uncanceledObjects[objIndex], withErrored);
			assertIsAlbumUpload(result);
			result = RD.AlbumUpload.findByFilename(uncanceledObjects[objIndex], withBoth);
			assertIsAlbumUpload(result);
		}
	
		for (var objIndex in canceledObjects) {
			var result = RD.AlbumUpload.findByFilename(canceledObjects[objIndex]);

			assertUndefined("Canceled object found by findByFilename with no params!", result);
			result = RD.AlbumUpload.findByFilename(canceledObjects[objIndex], withCanceled);
			assertIsAlbumUpload(result);
			result = RD.AlbumUpload.findByFilename(canceledObjects[objIndex], withErrored);
			assertUndefined("Canceled object found by findByFilename with only errored!", result);

			result = RD.AlbumUpload.findByFilename(canceledObjects[objIndex], withBoth);
			assertIsAlbumUpload(result);
		}
	
		for (var objIndex in erroredObjects) {
			var result = RD.AlbumUpload.findByFilename(erroredObjects[objIndex]);
			assertUndefined("Errored object found by findByFilename with no params!", result);
			result = RD.AlbumUpload.findByFilename(erroredObjects[objIndex], withCanceled);
			assertUndefined("Errored object found by findByFilename with only canceled!", result);
			result = RD.AlbumUpload.findByFilename(erroredObjects[objIndex], withErrored);
			assertIsAlbumUpload(result);
			result = RD.AlbumUpload.findByFilename(erroredObjects[objIndex], withBoth);
			assertIsAlbumUpload(result);
		}
	})
}

function testFindByFileNameDBTest() {
	forAllInitStates(function() {
		var dbObjects = [];
		forEachGoodDatabaseImage(function(serverData) {
			var mi = new RD.AlbumUpload().initFromDatabase(serverData);
			assertUndefined("Able to find meal image init'd from database through file object!", RD.AlbumUpload.findByFilename(mi.fileName));
		});
	})
}


/* IS MEAL IMAGE */

function testIsAlbumUpload() {
	forAllInitStates(function() {
		assertFalse("isAlbumUpload returned true for undefined!", RD.AlbumUpload.isAlbumUpload());
		assertFalse("isAlbumUpload returned true for null!", RD.AlbumUpload.isAlbumUpload(null));
		assertFalse("isAlbumUpload returned true for string!", RD.AlbumUpload.isAlbumUpload("abc"));
		assertFalse("isAlbumUpload returned true for number!", RD.AlbumUpload.isAlbumUpload(2));
		assertFalse("isAlbumUpload returned true for random array!", RD.AlbumUpload.isAlbumUpload([1, 2]));
		assertFalse("isAlbumUpload returned true for random hash!", RD.AlbumUpload.isAlbumUpload({a: 2, b: 3}));
	
		// now test a real RD.AlbumUpload
		var mi = new RD.AlbumUpload();
		assertTrue("Real RD.AlbumUpload didn't pass isAlbumUpload!", RD.AlbumUpload.isAlbumUpload(mi));
	
		// now test something fake like a MaelImage
		var fakeMI = new Array();
		assertFalse("isAlbumUpload returned true for empty hash!", RD.AlbumUpload.isAlbumUpload(fakeMI));
		fakeMI.localID = mi.localID;
		assertFalse("isAlbumUpload returned true for fake MI with real MI's localID!", RD.AlbumUpload.isAlbumUpload(fakeMI));
	
		// now break the RD.AlbumUpload and make sure it doesn't work
		delete mi.localID;
		assertFalse("isAlbumUpload returned true for broken MI with no localID!", RD.AlbumUpload.isAlbumUpload(mi));
	})
}

function assertIsAlbumUpload(mi) {
	// not strictly necessary but makes it easier to debug
	assertEvaluatesToTrue("RD.AlbumUpload passed to assertIsAlbumUpload is not a valid object (e.g. evaluates to true)!", mi);
	assertTrue("RD.AlbumUpload passed to assertIsAlbumUpload is not RD.AlbumUpload.", RD.AlbumUpload.isAlbumUpload(mi));
}

/*
refreshSortable
*/

function testRefreshSortable() {
	forAllInitStates(function() {
		// we're testing this by manually creating nodes
		// so we need to initialize ourselves
	
		// test that it picks up additional elements
		var limit = Math.round(Math.random() * 100);
		var ids = [];
		var div;
	
		for (var i = 0; i < limit; i++) {
			var orderBefore = RD.AlbumUpload._albumUploadsNode.sortable("toArray");
		
			// now add a div to it
			div = $(document.createElement("div"));
			div.addClass(RD.AlbumUpload.uploadNodeClass);
			div.attr("id", "foo" + i);
			ids.push(div.attr("id"));
			RD.AlbumUpload._albumUploadsNode.append(div);
	
			// refresh the sortable
			RD.AlbumUpload.refreshSortable();
	
			// now see if we've added that item
			var currentOrder = RD.AlbumUpload._albumUploadsNode.sortable("toArray");
			assertEquals("RefreshSortable didn't pick up a new item!", orderBefore.length + 1, currentOrder.length);
		
			// make sure it's in the right place
			assertEquals("New div was not put into appropriate place!", currentOrder.indexOf(div.attr("id")), currentOrder.length - 1);
		}
		
		// now make sure that all the IDs are present
		var idsToCheck = RD.AlbumUpload._albumUploadsNode.sortable("toArray");
		for (var i in ids) {
			assertTrue("Unable to find id after adding and refreshing!", idsToCheck.indexOf(ids[i]) >= 0);
		}
	
		// now try moving something and make sure it works
		// div is the last div created, so let's move it to the front
		var finalOrder = RD.AlbumUpload._albumUploadsNode.sortable("toArray");
		RD.AlbumUpload._albumUploadsNode.prepend(div);
		var ultimateOrder = RD.AlbumUpload._albumUploadsNode.sortable("toArray");
		assertNotEquals("After prepend, the order wasn't changed!", finalOrder, ultimateOrder)
	})
}

function testUpdateOrder() {
	forAllInitStates(function() {
		// we're testing this by manually creating nodes
		// so we need to initialize ourselves
	
		var ids = [];
		var mi;
	
		forEachGoodDatabaseImage(function(serverData) {
			// create a new meal mage
			// this automatically refreshes the sortable
			var orderBefore = RD.AlbumUpload.getSortOrder();

			mi = new RD.AlbumUpload().initFromDatabase(serverData);

			// make sure the now-stored order is updated to the new order
			// calculate what the order should be based on what we just did
			var orderShouldBe = (orderBefore.length > 0 ? orderBefore.split(",") : []); // compensate for "".split(",") === [""] 
			orderShouldBe.push(mi.id); 
			orderShouldBe = orderShouldBe.join(",");
			assertEquals("After new div, stored order != actual order!", orderShouldBe, RD.AlbumUpload.getSortOrder());
		});
	
		// get the individual IDs
		var finalOrder = RD.AlbumUpload.getSortOrder().split(",");
	
		// now make sure that all the IDs are present
		var idsToCheck = RD.AlbumUpload._albumUploadsNode.sortable("toArray");
		for (var i in ids) {
			assertTrue("Unable to find id after adding and refreshing!", idsToCheck.indexOf(ids[i]));
		}
	
		// now try moving something and make sure it works
		// div is the last div created, so let's move it to the front
		//RD.AlbumUpload._albumUploadsNode.remove(mi.node);
		RD.AlbumUpload._albumUploadsNode.prepend(mi.node);
	
		// now move that last ID to the front to simulate the move
		var ultimateOrder = finalOrder;
		var lastID = parseInt(ultimateOrder.pop()); // parseInt because the value will be a strin from a split-string array
		assertEquals("Last ID not equal to the last MI created!", lastID, mi.id);
		ultimateOrder = [lastID].concat(ultimateOrder);
	
		assertNotEquals("After prepend, the order wasn't changed!", finalOrder, ultimateOrder)
		assertEquals("Prepended meal node was not put into appropriate place in the order!  lastID: " + lastID + ", currentOrder: " + RD.showSource(ultimateOrder), ultimateOrder.indexOf(mi.id), 0);	
	})
}

/*
doUnfinishedUploadsExist
*/

function testDoUnfinishedUploadsExist() {
	forAllInitStates(function() {
		var queuedMeals = [], uploadingMeals = [];

		var limit = Math.round(Math.random() * 100);
			
		forAllGoodUploadsAndDatabaseImages(function(uploadData, serverData) {
			var mi = new RD.AlbumUpload();

			// now randomly act on the 
			var probability = Math.random();
		
			// if we haven't assigned this server ID, assign it
			if (!RD.AlbumUpload.findByRemoteId(serverData.id)) {
				// do upload first, or not
				if (probability > 0.5)
					mi.initFromUpload(uploadData).uploadStarted().uploadProgressed(0.5);
			
				// now init from database
				mi.initFromDatabase(serverData);
			}
			else {
				// do an init and maybe start upload
				mi.initFromUpload(uploadData);
			
				// now it's queued -- so randomly start it to uploading
				if (probability > 0.5) {
					mi.uploadStarted();
					uploadingMeals.push(mi);
				}
				else {
					// just leave it queued
					queuedMeals.push(mi);
				}
			}
		
			// make sure we're still working
			var failureString = "doUnfinishedUploadsExist returned the wrong value after adding meals (queued: " + queuedMeals.length + ", uploading: " + uploadingMeals.length + ")!";
			fn = (queuedMeals.length > 0 || uploadingMeals.length > 0 ? assertTrue : assertFalse);
			fn(failureString, RD.AlbumUpload.doUnfinishedUploadsExist());	
		});
	
		// now try removing items one by one, randomly clearing or canceling, until it should return false
		var mi;
		while (mi = queuedMeals.pop()) {		
			var probability = Math.random();
			if (probability > 0.5)
				mi.uploadCanceled();
			else
				RD.AlbumUpload.clear(mi.localID);

			// make sure we're still working
			var failureString = "doUnfinishedUploadsExist returned the wrong value after removing a queued meal (queued: " + queuedMeals.length + ", uploading: " + uploadingMeals.length + ")!";
			fn = (queuedMeals.length > 0 || uploadingMeals.length > 0 ? assertTrue : assertFalse);
			fn(failureString, RD.AlbumUpload.doUnfinishedUploadsExist());	
		}
	
		// the same for the uploading queue
		while (mi = uploadingMeals.pop()) {
			var probability = Math.random();
			if (probability > 0.5)
				mi.uploadCanceled();
			else
				RD.AlbumUpload.clear(mi.localID);
		
			// make sure we're still working
			var failureString = "doUnfinishedUploadsExist returned the wrong value after removing a canceled meal (queued: " + queuedMeals.length + ", uploading: " + uploadingMeals.length + ")!";
			fn = (queuedMeals.length > 0 || uploadingMeals.length > 0 ? assertTrue : assertFalse);
			fn(failureString, RD.AlbumUpload.doUnfinishedUploadsExist());	
		}
	
		// now we should be done
		assertFalse("After removing all queued and uploading meals, doUnfinishedUploadsExist still returns true!", RD.AlbumUpload.doUnfinishedUploadsExist());
	})
}


/*
doDeletedItemsExist
*/


function testDoDeletedItemsExist() {
	forAllInitStates(function() {
		var deletedMeals = [];

		forAllGoodUploadsAndDatabaseImages(function(uploadData, serverData) {
			var mi = new RD.AlbumUpload();

			// now randomly act on the 
			var probability = Math.random();
		
			// if we haven't assigned this server ID, assign it
			if (!RD.AlbumUpload.findByRemoteId(serverData.id)) {
				// do upload first, or not
				if (probability > 0.5)
					mi.initFromUpload(uploadData).uploadStarted().uploadProgressed(0.5);
			
				// now init from database
				mi.initFromDatabase(serverData);
			
				// now delete
				mi.toggleDeletion();
				if (probability > 0.75) {
					mi.toggleDeletion(); // undelete
				}
				else {
					deletedMeals.push(mi);
				}
			}
			else {
				// add some background noise
				// do an init and maybe start upload
				mi.initFromUpload(uploadData);
			
				// now it's queued -- so randomly start it to uploading
				if (probability > 0.5) {
					mi.uploadStarted();
				}
				else {
					// just leave it queued
				}
			}
		
			// make sure we're still working
			var failureString = "doDeletedMealsExist returned the wrong value after adding meals (deleted: " + deletedMeals.length + ")!";
			fn = (deletedMeals.length > 0 ? assertTrue : assertFalse);
			fn(failureString, RD.AlbumUpload.doDeletedItemsExist());	
		});
	
		// now try removing deleted items one by one, randomly clearing or canceling, until it should return false
		var mi;
		while ((mi = deletedMeals.pop())) {		
			RD.AlbumUpload.clear(mi.localID);

			// make sure we're still working
			var failureString = "doDeletedMealsExist returned the wrong value after removing a deleted meal (deleted: " + deletedMeals.length + ")!";
			fn = (deletedMeals.length > 0 ? assertTrue : assertFalse);
			fn(failureString, RD.AlbumUpload.doDeletedItemsExist());	
		}
	
	
		// now we should be done
		assertFalse("After removing all deleted meals, doDeletedMealsExist still returns true!", RD.AlbumUpload.doDeletedItemsExist());
	})
}


/*
becomeKey
Makes this meal image the key image.

Outcomes:
- afterward, the meal image node has class keyPic
- afterward, no other image nodes have class keyPic
*/
function testBecomeKeyPic() {
	forAllInitStates(function(details) {
	  if (details.keyImageNodeID) {
			forAllGoodUploadsAndDatabaseImages(function(uploadData, serverData) {
		    // set up a new meal image
		    var mi = new RD.AlbumUpload().initFromUpload(uploadData);
    
		    // if it's the first one with this serverData, init it from that and test becomeKeyImage
		    if (!RD.AlbumUpload.findByRemoteId(serverData.id)) {
		      mi.initFromDatabase(serverData);
      
		      // see if it automatically became the key pic
		      var wasAlreadyKeyPic = (RD.AlbumUpload.getKeyPic() && RD.AlbumUpload.getKeyPic().localID === mi.localID);

		      // if not, expect the event to fire
		      var eventFired = false;      
		      var eventShouldFire = (Math.random() > 0.5);
		      debug("Event should fire: " + eventShouldFire + ", was: " + wasAlreadyKeyPic);
		      var checkEvent = function(e) {
		        // make sure the event fired if it was supposed to
		        // unless it automagically became the key pic, in which case the event shouldn't have fired (tested elsewhere)
		        eventFired = true;

		        // only fire this for the specific meal image
		        // otherwise old event handlers will cause this test to fail
		        var forThis = e.mealImage && e.mealImage.localID === mi.localID;

		        if (forThis && (eventShouldFire === false || wasAlreadyKeyPic)) {
		          fail("Event fired when it shouldn't have!");
		        }
		      }
					fail("need to update event");
		    	RD.AlbumUpload.handleNewKeyImage(checkEvent);
            
		      // now have it become the key pic
		      var result = mi.becomeKeyPic({surpressEvent: !eventShouldFire});
		      assertTrue("becomeKeyPic didn't return true!", result);
      
		      // make sure the event fired if it should have
		      if (eventShouldFire && !wasAlreadyKeyPic) {
		        assertTrue("Event didn't fire when it should have!", eventFired);
		      }
      
		      // make sure it's the key pic
		      var newKeyPic = RD.AlbumUpload.getKeyPic();
		      assertTrue("RD.AlbumUpload key pic was not a meal image even after explicit call! (MI._keyPic: " + RD.AlbumUpload._keyPic + ", node: " + RD.AlbumUpload._keyImageDataNode.val() + ")", RD.AlbumUpload.isAlbumUpload(newKeyPic));
      
		      assertEquals("Image did not become the key pic!", newKeyPic.localID, mi.localID);
		      assertEquals("RD.AlbumUpload._keyPic !== key pic!", RD.AlbumUpload._keyPic, mi.localID);

		      // make sure the DOM node has the right value
		      // remember node value is a string
		      assertEquals("keypic node did not store the right value!", RD.AlbumUpload._keyImageDataNode.val(), mi.id + ""); 
      
		      // make sure the mi's node -- and only that one -- has class keyPic
		      var nodesWithKeyPic = RD.AlbumUpload._albumUploadsNode.find(".keyPic");
		      assertEquals("More than one node had class .keyPic!", nodesWithKeyPic.length, 1);
		      assertEquals("The new key pic didn't have class key pic!", nodesWithKeyPic[0], mi.node[0]);
		    }
		  });
		}
	})
}


function testKeyPicWithSameValue() {
	forAllInitStates(function(details) {
	  if (details.keyImageNodeID) {
		  // test to make sure that subsequent calls for the same meal ID don't change the value
		  // also tests that clear removes the key pic, incidentally 
		  forEachGoodDatabaseImage(function(serverData) {
		    var mi = new RD.AlbumUpload().initFromDatabase(serverData);
		    var previousKeyPic = RD.AlbumUpload.getKeyPic();
		    assertTrue("RD.AlbumUpload key pic was not a meal image even after initFromDB! (MI._keyPic: " + RD.AlbumUpload._keyPic + ", node: " + RD.AlbumUpload._keyImageDataNode.val() + ")", RD.AlbumUpload.isAlbumUpload(previousKeyPic));
		    assertEquals("RD.AlbumUpload did not become key pic on database initialization!", mi.localID, previousKeyPic.localID);
    
		    // now call it again
		    var result = mi.becomeKeyPic();
		    var keyPic = RD.AlbumUpload.getKeyPic();
		    assertTrue("RD.AlbumUpload did not return true when called twice for the same MI!", result);
		    assertEquals("KeyPic changed after second call by same object!", mi.localID, keyPic.localID);
  
		    RD.AlbumUpload.clear(mi.localID);
		  });
		}
	})
}
/*
getKeyPic
Gets the key pic object.

Outcomes:
- returns mealImage corresponding to the value of RD.AlbumUpload._keyPic (via findByLocalId, so the same results for invalid/undefined IDs)
*/

function testGetKeyPic() {
	forAllInitStates(function(details) {
	  if (details.keyImageNodeID) {
		  // test along several circumstances
  
		  // 1. nothing done
		  assertUndefined("No key pic set, but value was returned!", RD.AlbumUpload.getKeyPic());
  
		  // 2. improper value that doesn't map to any image
		  RD.AlbumUpload._keyPic = 2;
		  assertUndefined("Key pic set to invalid value, but getKeyPic returned a value!", RD.AlbumUpload.getKeyPic());
  
		  // 3. an actual value
		  // get the key image set
		  var mi = new RD.AlbumUpload().initFromDatabase(testData.goodDatabaseImages[0]);
		  assertEquals("After creating a meal image with no key image, the key image wasn't properly set!", mi.localID, RD.AlbumUpload.getKeyPic().localID);
		}
	})
}


/* TEARDOWN TEST */

function testAlbumUploadShutdown() {
  // make sure shutdown works properly, otherwise all our tests are iffy
  RD.AlbumUpload._shutdown(); // to test

  assertUndefined("RD.AlbumUpload shutdown did not remove _initialized!", RD.AlbumUpload._initialized);
  assertUndefined("RD.AlbumUpload shutdown did not remove debug!", RD.AlbumUpload.prototype.debug);
  assertUndefined("RD.AlbumUpload shutdown did not remove _images!", RD.AlbumUpload._imagesForMeal);
  assertUndefined("RD.AlbumUpload shutdown did not remove image sort order node!", RD.AlbumUpload._imageSortOrderNode);
  assertUndefined("RD.AlbumUpload shutdown did not remove key image node!", RD.AlbumUpload._keyImageDataNode);
  assertUndefined("RD.AlbumUpload shutdown did not remove placeholder node!", RD.AlbumUpload._placeholderNode);
  assertUndefined("RD.AlbumUpload shutdown did not remove _keyPic!", RD.AlbumUpload._keyPic);
  assertUndefined("RD.AlbumUpload shutdown did not remove _albumUploadsNode!", RD.AlbumUpload._albumUploadsNode);
	assertUndefined("RD.AlbumUpload shutdown did not remove clearedObject to an empty hash!", RD.AlbumUpload.clearedObject);
  
	for (var templateName in RD.AlbumUpload.internals._JAML_TEMPLATES) {
		if (RD.AlbumUpload.internals._JAML_TEMPLATES.hasOwnProperty(templatesName)) {
		  assertUndefined("RD.AlbumUpload shutdown did not remove Jaml templates!", Jaml.templates[templateName]);
	  }
	}
}

/* SETUP AND TEARDOWN */
var debug;

function setUp() {
    // runs standard setup
    debug = _debug;
    
    _addAlbumUploadDiv();
    _addAlbumUploadSortOrder();
    _addAlbumUploadPlaceholder();
		_addKeyImageNode();
    _initTestData();
}

function defaultInitializationParams() {
	return $.extend({}, {
		albumNodeID: "albumUploads",
		sortOrderStorageID: "imageSortOrder",
		placeholderNodeID: "albumUploadsPlaceholder",
		keyImageNodeID: "meal_key_picture_id"
	});
}

function initializationParamsNoPlaceholder() {
	var params = defaultInitializationParams();
	delete params.placeholderNodeID;
	return params;
}

function initializationParamsNoKeyImage() {
	var params = defaultInitializationParams();
	delete params.keyImageNodeID;
	return params;
}

function initializationParamsNoOptionalFields() {
	var params = defaultInitializationParams();
	delete params.placeholderNodeID;
	delete params.keyImageNodeID;
	return params;
}

function forAllInitStates(fn) {
	var allParams = [defaultInitializationParams(), 
										initializationParamsNoPlaceholder(), 
										initializationParamsNoKeyImage(), 
										initializationParamsNoOptionalFields()
									];
									
  for (var i = 0; i < allParams.length; i++) {
		// try against this init state
		RD.AlbumUpload.initialize(allParams[i]);
		fn(allParams[i]);
		// then reset state
		tearDown();
		setUp(); 
	}
	
}

function tearDown() {
    debug = null;
    _removeAlbumUploadDiv();
    _removeAlbumUploadSortOrder();
    _removeAlbumUploadPlaceholder();
	  _removeKeyImageDataNode();
    _destroyTestData();
    RD.AlbumUpload._shutdown();
}

function _addAlbumUploadDiv() {
    if (!document.getElementById("albumUploads")) {
       div = document.createElement("div");
       div.id = "albumUploads";
       document.getElementById("testHanger").appendChild(div); 
    }    
}

function _addAlbumUploadPlaceholder() {
  $("#albumUploads").append($("<div>", {id: "albumUploadsPlaceholder"}))
}

function _addAlbumUploadSortOrder() {
    if (!document.getElementById("imageSortOrder")) {
       input = document.createElement("input");
       input.id = "imageSortOrder";
       input.type = 'hidden';
       document.getElementById("testHanger").appendChild(input); 
    }    
}

function _addKeyImageNode() {
    if (!document.getElementById("meal_key_picture_id")) {
       input = document.createElement("input");
       input.id = "meal_key_picture_id";
       input.type = 'hidden';
       document.getElementById("testHanger").appendChild(input); 
    }
}

function _removeAlbumUploadPlaceholder() {
  $("#albumUploadsPlaceholder").remove();
}

function _removeAlbumUploadDiv() {
    if (RD.AlbumUpload._albumUploadsNode)
        RD.AlbumUpload._albumUploadsNode.remove();
}

function _removeAlbumUploadSortOrder() {
    if (input = document.getElementById("imageSortOrder"))
        input.parentNode.removeChild(input);
}

function _removeKeyImageDataNode() {
    if (input = document.getElementById("meal_key_picture_id"))
        input.parentNode.removeChild(input);
}

function _removeJaml(template) {
  delete Jaml.templates[template];
}

function _debug(args) {

}

/* TEST DATA HELPERS */
var testData, _errorDataStore;

function _initTestData() {
  testData = {};
  testData.goodFileUploads = [];
  testData.goodFileUploads.push({
    name:"DSC01152.JPG", 
    creationdate:(new Date(1256834007000)), 
    modificationdate:(new Date(1256834010000)), 
    post:{}, 
    type:"JPEG", 
    index:0,  
    filestatus:-1, 
    size:3982465, 
    id:"SWFUpload_0_0"
  });
  testData.goodFileUploads.push({
    // make sure we pass when we get 0's, which Javascript accepts as false
    name:"0", 
    creationdate:(new Date(1256834007000)), 
    modificationdate:(new Date(1256834010000)), 
    post:{}, 
    type:"JPEG", 
    index:0,  
    filestatus:-1, 
    size:3982465, 
    id: 0
  });
  testData.goodFileUploads.push({
    name:"DSC01352.JPG", 
    creationdate:(new Date(1256834007000)), 
    modificationdate:(new Date(1256834010000)), 
    post:{}, 
    type:"JPEG", 
    index:0,  
    filestatus:-1, 
    size:3982465, 
    id:"SWFUpload_0_2"
  });
  testData.goodFileUploads.push({
    name:"DSC0152.JPG", 
    creationdate:(new Date(1256834007000)), 
    modificationdate:(new Date(1256834010000)), 
    post:{}, 
    type:"JPEG", 
    index:0,  
    filestatus:-1, 
    size:3982465, 
    id:"SWFUpload_0_1"
  });
  
  testData.badFileUploads = {};
  testData.badFileUploads["null"] = null;
  testData.badFileUploads["notObject"] = "foo and bar!";
  testData.badFileUploads["noID"] = {
    name:"DSC012452.JPG", 
    creationdate:(new Date(1256834007000)), 
    modificationdate:(new Date(1256834010000)), 
    post:{}, 
    type:"JPEG", 
    index:0,  
    filestatus:-1, 
    size:3982465, 
  };
  testData.badFileUploads["noName"] = {
    creationdate:(new Date(1256834007000)), 
    modificationdate:(new Date(1256834010000)), 
    post:{}, 
    type:"JPEG", 
    index:0,  
    filestatus:-1, 
    size:3982465, 
    id:"SWFUpload_1_1"
  };
  
  // good database info
  testData.goodDatabaseImages = [];
  testData.goodDatabaseImages.push({
    thumbImageURL:"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/4865/DSC01152_thumb_vertical.JPG",
    "width":3000,
    "fullImageURL":"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/4865/DSC01152.JPG",
    "isKey":false,
    "height":4000,
    "id":4865
  });
  testData.goodDatabaseImages.push({
    // make sure we can handle id === 0 -- should never happen, but in case
    thumbImageURL: 0,
    "width": 0,
    "fullImageURL": 0,
    "isKey":false,
    "height": 0,
    "id": 0
  }); 
  // equal width and height
  testData.goodDatabaseImages.push({
    thumbImageURL:"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/4865/DSC01152_thumb_vertical.JPG",
    "width":4000,
    "fullImageURL":"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/4865/DSC01152.JPG",
    "isKey":false,
    "height":4000,
    "id":4861125
  });
  testData.goodDatabaseImages.push({
    thumbImageURL:"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/2342/DSC0112_thumb_vertical.JPG",
    "width":4000,
    "fullImageURL":"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/2342/DSC0112.JPG",
    "isKey":false,
    "height":3000,
    "id":1234
  });
  testData.goodDatabaseImages.push({   
    "thumbImageURL":"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/23423/DSC011332_thumb_vertical.JPG",
    "fullImageURL":"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/23423/DSC011332.JPG",
    "isKey":false,
    "id":12343
  });
  
  // bad database info
  testData.badDatabaseImages = {};
  testData.badDatabaseImages["null"] = null;
  testData.badDatabaseImages["notObject"] = "foo and bar!";
  testData.badDatabaseImages["anotherObject"] = {};
  testData.badDatabaseImages["noThumb"] = {
    "width":4000,
    "fullImageURL":"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/2341/DSC012.JPG",
    "isKey":false,
    "height":3000,
    "id":123
  };
  testData.badDatabaseImages["noFull"] = {
    thumbImageURL:"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/2342/DSC0112_thumb_vertical.JPG",
    "width":4000,
    "isKey":false,
    "height":3000,
    "id":123
  };
  testData.badDatabaseImages["noId"] = {
    thumbImageURL:"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/2342/DSC0112_thumb_vertical.JPG",
    "width":4000,
    "fullImageURL":"http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/2342/DSC0112.JPG",
    "isKey":false,
    "height":3000
  };	
}

function errorData() {
	if (!_errorDataStore) {
		_errorDataStore = {}
		_errorDataStore.recoverableUploadErrors = [];
		for (var i in testData.goodFileUploads) {
			mi = new RD.AlbumUpload().initFromUpload(testData.goodFileUploads[i]);
			_errorDataStore.recoverableUploadErrors.push({
				isRecoverable: true,
				shortDescription: "Upload test " + mi.localID,
			});
		}
	
		_errorDataStore.unrecoverableUploadErrors = [];
		for (var i in testData.goodFileUploads) {
			mi = new RD.AlbumUpload().initFromUpload(testData.goodFileUploads[i]);
			_errorDataStore.unrecoverableUploadErrors.push({
				isRecoverable: false,
				shortDescription: "Upload test " + mi.localID,
			});
		}
	}
	return _errorDataStore;
}

function databaseDataFromIndex(i) {
  return {   
    "thumbImageURL": "http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/23423/DSC011332_thumb_vertical.JPG",
    "fullImageURL": "http://localhost/~ahkoppel2/mealstromimages/images/meals/0000/23423/DSC011332.JPG",
    "isKey": false,
    "id": i
  };
}

function uploadDataFromIndex(i) {
	return {
    name:"uploadFromIndex" + i + ".JPG", 
    creationdate:(new Date(1256834007000)), 
    modificationdate:(new Date(1256834010000)), 
    post:{}, 
    type:"JPEG", 
    index:0,  
    filestatus:-1, 
    size:3982465, 
    id:"SWFUpload_" + i + "_" + i
  }
}

function _destroyTestData() {
  delete testData;
}

function forEachGoodUpload(fn) {
	assertIsFunction("forEachGoodUpload wasn't passed a function!", fn);
	for (var goodFileIndex in testData.goodFileUploads) {
		fn(testData.goodFileUploads[goodFileIndex]);
	}
}

function forEachGoodDatabaseImage(fn) {
	assertIsFunction("forEachGoodDatabaseImage wasn't passed a function!", fn);
	for (var goodDataIndex in testData.goodDatabaseImages) {
		fn(testData.goodDatabaseImages[goodDataIndex]);
	}
}

function forAllGoodUploadsAndDatabaseImages(fn) {
	assertIsFunction("forAllGoodUploadsAndDatabaseImages wasn't passed a function!", fn);
	forEachGoodUpload(function(uploadData) {
		forEachGoodDatabaseImage(function(serverData) {
			fn(uploadData, serverData);
		})
	})
}

function forEachUnrecoverableError(fn) {
	assertIsFunction("forEachUnrecoverableError wasn't passed a function!", fn);
	for (var errorType in errorData().unrecoverableUploadErrors) {
		fn(errorData().unrecoverableUploadErrors[errorType]);
	}
}
// error data
// since this invokes new RD.AlbumUpload() and other functions, it's called as needed rather than in setUp

</script>

<div id="testHanger">
</div>
</body>
</html>