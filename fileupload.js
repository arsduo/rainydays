/*
RD.FileUpload.initialize
Assumptions:
- gets an options hash that contains certain required nodes and certain optional nodes (failure: throws exception)
- #imageSortOrder exists (failure: throws exception, since we cannot continue)
- #fileUploads exists (failure: throws exception, since we cannot continue)
- if options.keyImageId is provided, the corresponding node exists (failure: throws exception, since we cannot continue)
- if options.placeholderNodeID is provided, the corresponding node exists (failure: throws exception, since we cannot continue)

Other outputs:
- if initialized is already true, does nothing
- pre-initializes images array
- sets sort order node
- sets _FileUploadsNode
- sets clearedObject
- sets up Jaml templates
- sets initialized to true
*/
RD.FileUpload = {
	uploaders: [],
	
	initialize: function() {
		if (!this._initialized) {
			// add language support
	  	RD.Utils.addLanguageSupport(RD.FileUpload);
		}
	},
	
	create: function(options) {
		this.initialize();
		
		if (!options || typeof(options) !== "object") {
			throw("RD.FileUpload was not passed an options hash!")
		}
	
		if (!options.swfuploadOptions) {
			throw("RD.FileUpload._initialize was not passed swfuploadOptions!");
		}
	
		// limit the queue to one file at a time
		options.swfuploadOptions.file_queue_limit = 1
				
		var instance = Object.create(this.instancePrototype).init(options);	
		// ensure we know what to expect from the server
		instance.fileFieldName = options.fileFieldName || "fullImageURL";
		
		this.uploaders.push(instance);
	},
	
	instancePrototype: {
		init: function(options) {
			this.uploadManager = RD.UploadManager.create(options.swfuploadOptions, this);
			
			if (!options.inputNodeID) {
				throw("A new FileUpload was not given an input node!")
			}
			this.inputNode = $("#" + options.inputNodeID);

			if (options.progressBarID) {
				this.progressBar = $("#" + options.progressBarID);
				if (this.progressBar.length === 0) {
					throw("New Fileupload could not find progressBar #" + options.progressBarID + "! Cannot continue.");		    
				}		
			}

			if (options.percentageID) {
				this.percentage = $("#" + options.percentageID);
				if (this.percentage.length === 0) {
					throw("New Fileupload could not find percentage #" + options.percentageID + "! Cannot continue.");		    
				}		
			}

			return this;
		},
		
		/* 
		newUploadObject
		The object that handles actions generated by the file upload.  Always returns this; exists for compatibility
		with multi-file uploads (where this would generate a new object).
		*/
		newUploadObject: function() {
			return this;
		},
		
		/*
		initFromUpload
		This initializes a new RD.FileUpload using information provided by the SWF uploader.  

		Assumptions:
		- uploadDetails is not null and is a valid file object per SWF documentation (failure: triggers and returns _badFileUpload)
			- see http://demo.swfupload.org/Documentation/#fileobject

		Other outcomes / test cases:
		- this fileUpload is findable by the fileObject (uploadDetails)
		- has a fileObject === uploadDetails
		- has .filename === uploadDetails.name
		- has queued status
		- makes the overall page node
		- returns this RD.FileUpload
		*/

		initFromUpload: function(uploadDetails) {
			RD.debug("Initializing file " + this.localID + " from upload.");

		  // error check
		  if (!(uploadDetails && uploadDetails.id && uploadDetails.name)) {
		   	RD.debug("ERROR: Uploading file must exist (" + uploadDetails + ") and have an id (" + (uploadDetails ? uploadDetails.id : "obj is null") + ") and a name (" + (uploadDetails ? uploadDetails.name : "obj is null") + ")");
				return this._badFileUpload(uploadDetails); // which prints out the details
		  }

		  // save details
		  this.filename = uploadDetails.name;
		  this.fileObject = uploadDetails;

		  // set status
		  this.status = RD.FileUpload._STATUS["queued"];

			// trigger an event so the page can be dirtied, etc.
			this.inputNode.trigger("fileUploadStarted", {fileHandler: this, details: uploadDetails});

		  // return
		  RD.debug("Initialization done -- image has filename  " + this.filename);
		  return this;
		},
		
		/*
		uploadStarted
		This marks when an upload starts, updating status and visuals.

		Other outcomes / test cases:
		- has uploading status
		- progressBar returns 0 for .progressbar("option", "value") (returns null if no progressbar set)
		- if there's a percentage, it's set to 0 (returns null if no percentage set)
		- returns this RD.FileUpload
		*/

		uploadStarted: function() {
		    RD.debug("Upload started for fileUpload " + this.localID);

		    // generate the progress bar
				if (this.progressBar) {
					RD.debug("Found progress bar " + RD.showSource(this.progressBar));
					this.progressBar.progressbar({value: 0})
					if (this.progressBar.css("display") === "none") {
						this.progressBar.css("display", "block");
					}
				}
				
		    // generate the percentage
				if (this.percentage) {
					RD.debug("Found percentage bar " + RD.showSource(this.progressBar));
					this.progressBar.progressbar({value: 0});
				}

		    // set the status
		    this.status = RD.FileUpload._STATUS["uploading"];

		    return this;
		},
		
		/*
		uploadCanceled
		This marks when an upload starts, updating status and visuals.

		Assumptions:
		- Jaml template "canceled" exists (failure: throws exception w/ an alert, since the page itself is broken we can't recover) 

		Other outcomes / test cases:
		- has canceled status
		- content replaced by canceled content
		- returns this RD.FileUpload
		*/

		uploadCanceled: function() {
			// set the status
			this.status = RD.FileUpload._STATUS["canceled"];

			// fire a canceled event
						
			return this;
		},

		/*
		uploadProgressed
		This is triggered when an upload has made progress, updating status and visuals.

		Assumptions:
		- Nothing external has removed the progressbar element (failure: reruns this.uploadStarted) 

		Other outcomes / test cases:
		- this.progressBar.progressbar("option", "value") is equal to percentage * 100
		- when we hit 100%, throw up a processing message while the server thinks, 
		- returns this RD.FileUpload
		*/

		uploadProgressed: function(percentage) {
		    RD.debug("Upload progressed to " + percentage + "% for fileUpload " + this.localID);

		    // update the progressbar
				if (this.progressBar) {
		    	this.progressBar.progressbar("option", "value", percentage * 100);
					// if percentage is 100%, say processing
					if (percentage > 0.99) {
						// should we have something say processing?
						//.html(RD.FileUpload.text("processing_uploaded_file"));
					}
    		}
				
				// update the percentage
				if (this.percentage) {
					this.percentage.html(Math.round(percentage * 100));
				}
		
		    // return the item
		    return this;
		},

		/*
		uploadErrored
		This is triggered when an upload encounters an error, and either aborts or gets queued again.

		Other outcomes / test cases:
		- errorCount is incremented (or set to 1 if it was null)
		- if the error is recoverable and it hasn't over-errored, it's set to queued again
		- if not, the status is set to errored
		- returns this RD.FileUpload
		*/

		uploadErrored: function(errorDetails) {
			errorDetails.fileUpload = this;
			this.status = RD.FileUpload._STATUS["errored"];

			// add an error count
			if (!this.errorCount)
				this.errorCount = 1;
			else
				this.errorCount++;

			if (errorDetails.isRecoverable && this.errorCount <= RD.FileUpload.RETRY_LIMIT) {
				RD.debug("Retrying upload.");
				this.status = RD.FileUpload._STATUS["queued"]; // if we're retrying it
			}	
			else {
				// update visible fields
				if (this.progressBar) {
					this.progressBar.html(RD.FileUpload.text("error"));
				}
				if (this.percentage) {
					this.percentage.html(RD.FileUpload.text("error"));
				}
			}
			
			RD.debug("Error details shortDescription: " + errorDetails.shortDescription);

			return this;
		},

		/*
		uploadCompleted
		Fired when the fileUpload has finished uploading; triggers initialization from the database.

		Assumptions:
		- fileDetails is a valid object (failure: turns the file image to an error)

		Other outcomes / test cases:
		- returns the same output as initFromDatabase
		*/

		uploadCompleted: function(fileDetails) {
			RD.debug("Received results! " + fileDetails);
			if (!fileDetails || typeof(fileDetails) != "object") {
				return this._badServerResponse(fileDetails);
		  }
  
			this.status = RD.FileUpload._STATUS.visible;

			// validate server details
			if (!(fileDetails && fileDetails[this.fileFieldName])) {
				throw("Completed file upload did not exist and have field " + this.fileFieldName);
			}

			// save the data
			RD.debug("Getting " + this.fileFieldName + ": " + fileDetails[this.fileFieldName])
			this.inputNode.val(fileDetails[this.fileFieldName]).trigger("change");
			this.inputNode.trigger("fileUploadCompleted", fileDetails);

			if (this.progressBar) {
				setTimeout($.proxy(function() { this.progressBar.fade(400); }, this), 3000)
			}

		  return this;
		},

		/* STATUS ACCESSORS */

		/*
		isRetrying
		Accessor to see if the file image is being reuploaded after an error.

		Outcomes / test cases:
		- returns true if the file is queued but has an errorCount
		*/

		isRetrying: function() {
			return (this.status === RD.FileUpload._STATUS["queued"] && this.errorCount > 0);
		},

		/*
		shouldCancelUpload
		Accessor to see if the file image should be canceled because it's been tried too many times.

		Outcomes / test cases:
		- returns true if the file has errored more than the retry limit
		*/

		shouldCancelUpload: function() {
			return (this.errorCount > RD.FileUpload.RETRY_LIMIT);
		},


		/*
		Status Accessors
		Accessors to check the state of the file.

		Outcomes / test cases:
		- returns true if the appropriate status is set
		*/

		isCreated: function() { return this.status === RD.FileUpload._STATUS["created"]; },
		isVisible: function() { return this.status === RD.FileUpload._STATUS["visible"]; },
		isErrored: function() { return this.status === RD.FileUpload._STATUS["errored"]; },
		isCanceled: function() { return this.status === RD.FileUpload._STATUS["canceled"]; },
		isQueued: function() { return this.status === RD.FileUpload._STATUS["queued"]; },
		isUploading: function() { return this.status === RD.FileUpload._STATUS["uploading"]; },
		isDeleting: function() { return this.status === RD.FileUpload._STATUS["deleting"]; },

		/*
		findByFileObject
		This method always returns this object; it exists for compatibility with multi-file uploads.

		Outcomes:
		- returns this
		*/

		findByFileObject: function(fileObject, findOptions) {
			return this;
		},
		
		
		/*
		doUnfinishedUploadsExist
		Returns false -- exists for compatibility.  All uploads start immediately and the queue is limited to one item.
		*/

		doUnfinishedUploadsExist: function() {
		  return false;
		},
		
		_badServerResponse: function(response) {
			// used when the server responds successfully, but the content isn't what we expect
			// notify the console of the error, then render the error view
			// unfortunately, we can't recover since SWFUpload interpreted this as a successful upload and hence won't let it be requeued
			RD.debug("Bad server response! " + (response ? RD.showSource(response) : " null!"));
			return this.uploadErrored({isRecoverable: false, shortDescription: "Invalid server response"});
		},

		_badFileUpload: function(data) {
			// used when the SWFUploader adds a file, but that file is missing essential content
			// I expect this never to fire, but better to be secure than sorry
			// notify the console of the error, then render the error view
			// we can't recover, since SWFUpload doesn't requeue on file errors
			RD.debug("Bad file upload! " + (data ? RD.showSource(data) : "null!"));
			return this.uploadErrored({isRecoverable: false, shortDescription: "Problem uploading file!"});	
		}
		


	},
	
	/* CONSTANTS */
	// internal use only.  To verify a status, use the accessor methods above.
	_STATUS: (function() {
		// we use .length somewhere, hence the array rather than a hash
		var status = [];
		status.created = -1;
		status.queued = 0;
		status.uploading = 1;
		status.errored = 2;
		status.deleting = 3;
		status.canceled = 4;
		status.visible = 5;
		
		return status;
	}()),
	
	RETRY_LIMIT: 1,

	/* PRIVATE FUNCTIONS */
	_shutdown: function() {
		// used for testing
		// reset all initialized variables to nothing
	},

	// internal data
	TEXT: {
		en: {
			error: "Error!",
			processing_uploaded_file: "Processing...",
		}
	}
};